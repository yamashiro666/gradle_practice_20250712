ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¸ã¨ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹
ãƒãƒ£ãƒƒãƒˆå±¥æ­´

ã‚ãªãŸ:
javaã®truststrategyã‚’ä½¿ã£ã¦ã‚µãƒ¼ãƒè¨¼æ˜æ›¸ã®æ¤œè¨¼ã‚’è¡Œã†å®Ÿè£…ã‚’ã‹ã‘ã¾ã™ã‹ã€‚
è¨¼æ˜æ›¸ãƒã‚§ãƒ¼ãƒ³ã‚’æ„è­˜ã—ãŸå®Ÿè£…ã‚’ã—ã¦ãã ã•ã„ã€‚
ChatGPT:

æ€è€ƒæ™‚é–“: 2m 3s
ã¯ã„ã€ã§ãã¾ã™ã€‚Apache HttpClient ã® TrustStrategy ã‚’ä½¿ã„ã¤ã¤ã€è¨¼æ˜æ›¸ãƒã‚§ãƒ¼ãƒ³ã‚’æ­£ã—ãçµ„ã¿ç«‹ã¦ã¦ PKIX ã§æ¤œè¨¼ã™ã‚‹å®Ÿè£…ä¾‹ã§ã™ã€‚
ï¼ˆæ³¨: Hostname æ¤œè¨¼ã¯ TrustStrategy ã§ã¯è¡Œãˆãªã„ãŸã‚ã€å¾Œè¿°ã®ã¨ãŠã‚Š DefaultHostnameVerifier ã‚’å¿…ãšä½µç”¨ã—ã¦ãã ã•ã„ã€‚ï¼‰

1) ãƒã‚§ãƒ¼ãƒ³æ¤œè¨¼ã™ã‚‹ TrustStrategy å®Ÿè£…
package com.example.tls;

import org.apache.hc.core5.ssl.TrustStrategy; // HttpClient 5 ç³»ã‚’æƒ³å®šï¼ˆ4.5 ç³»ãªã‚‰ org.apache.http.ssl.TrustStrategyï¼‰

import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;
import java.security.KeyStore;
import java.security.cert.*;
import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

/**
 * ã‚µãƒ¼ãƒã‹ã‚‰æç¤ºã•ã‚ŒãŸè¨¼æ˜æ›¸ãƒã‚§ãƒ¼ãƒ³ã‚’ PKIX ã§æ¤œè¨¼ã™ã‚‹ TrustStrategyã€‚
 * - ã‚·ã‚¹ãƒ†ãƒ æ—¢å®šã®ä¿¡é ¼ã‚¹ãƒˆã‚¢ + ä»»æ„ã®ã‚«ã‚¹ã‚¿ãƒ  TrustStore ã‚’ä¿¡é ¼ã‚¢ãƒ³ã‚«ãƒ¼ã¨ã—ã¦ä½¿ç”¨
 * - PKIX CertPathBuilder ã§ãƒ«ãƒ¼ãƒˆã¾ã§ã®çµŒè·¯ã‚’æ§‹ç¯‰ã—ã¦æ¤œè¨¼
 * - æœ«ç«¯è¨¼æ˜æ›¸ã® KeyUsage / EKU(serverAuth) / æœ‰åŠ¹æœŸé™ ã‚’è¿½åŠ ãƒã‚§ãƒƒã‚¯
 * - Hostname æ¤œè¨¼ã¯åˆ¥é€” DefaultHostnameVerifier ã§è¡Œã£ã¦ãã ã•ã„
 */
public final class ChainValidatingTrustStrategy implements TrustStrategy {

    private final Set<TrustAnchor> trustAnchors;
    private final Collection<X509Certificate> extraIntermediates;
    private final boolean enableRevocation; // OCSP/CRL ã‚’ä½¿ã£ãŸå¤±åŠ¹ç¢ºèªï¼ˆå¿…è¦ã«å¿œã˜ã¦ trueï¼‰

    private static final String EKU_SERVER_AUTH_OID = "1.3.6.1.5.5.7.3.1";

    public static Builder builder() {
        return new Builder();
    }

    private ChainValidatingTrustStrategy(Set<TrustAnchor> trustAnchors,
                                         Collection<X509Certificate> extraIntermediates,
                                         boolean enableRevocation) {
        this.trustAnchors = Objects.requireNonNull(trustAnchors, "trustAnchors");
        this.extraIntermediates = Objects.requireNonNull(extraIntermediates, "extraIntermediates");
        this.enableRevocation = enableRevocation;
    }

    @Override
    public boolean isTrusted(final X509Certificate[] chain, final String authType) throws CertificateException {
        if (chain == null || chain.length == 0) {
            throw new CertificateException("Empty server certificate chain.");
        }

        // 0 ãŒã‚¨ãƒ³ãƒ‰ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ï¼ˆã‚µãƒ¼ãƒï¼‰æƒ³å®š
        final X509Certificate endEntity = chain[0];

        try {
            // presented chain + extra intermediates ã‚’ CertStore ã¨ã—ã¦æŠ•å…¥
            List<X509Certificate> presented = Arrays.asList(chain);
            Collection<X509Certificate> allIntermediates = new ArrayList<>(presented);
            allIntermediates.addAll(extraIntermediates);

            CertStore certStore = CertStore.getInstance("Collection",
                    new CollectionCertStoreParameters(allIntermediates));

            // ç›®æ¨™ï¼ˆã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼‰ã¯ã‚µãƒ¼ãƒè¨¼æ˜æ›¸
            X509CertSelector selector = new X509CertSelector();
            selector.setCertificate(endEntity);

            PKIXBuilderParameters params = new PKIXBuilderParameters(trustAnchors, selector);
            params.addCertStore(certStore);

            // å¤±åŠ¹ç¢ºèª
            params.setRevocationEnabled(enableRevocation);
            if (enableRevocation) {
                // é«˜åº¦ã«ã‚„ã‚‹ãªã‚‰ PKIXRevocationChecker ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°
                CertPathValidator cpv = CertPathValidator.getInstance("PKIX");
                PKIXRevocationChecker revChecker = (PKIXRevocationChecker) cpv.getRevocationChecker();
                // ä¾‹: CRL å„ªå…ˆã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãªã— ãªã©ï¼ˆå¿…è¦ã«å¿œã˜ã¦èª¿æ•´ï¼‰
                revChecker.setOptions(EnumSet.of(
                        PKIXRevocationChecker.Option.PREFER_CRLS,
                        PKIXRevocationChecker.Option.NO_FALLBACK
                ));
                params.addCertPathChecker(revChecker);
            }

            // çµŒè·¯æ§‹ç¯‰ï¼ˆé †ä¸åŒã®ãƒã‚§ãƒ¼ãƒ³ã§ã‚‚ OKï¼‰
            CertPathBuilder builder = CertPathBuilder.getInstance("PKIX");
            PKIXCertPathBuilderResult result = (PKIXCertPathBuilderResult) builder.build(params);

            // PKIX ã®æ§‹ç¯‰æ™‚ç‚¹ã§ç½²å/ç™ºè¡Œè€…/æœŸé™ãªã©ã¯æ¤œè¨¼æ¸ˆã¿ã ãŒã€
            // Web ã‚µãƒ¼ãƒç”¨é€”ã¨ã—ã¦ã®è¿½åŠ ãƒã‚§ãƒƒã‚¯ã‚’ã—ã¦ãŠã
            checkEndEntityForTlsServer(endEntity);

            // ã“ã“ã¾ã§æ¥ã‚Œã°ä¿¡é ¼å¯
            return true;

        } catch (CertPathBuilderException e) {
            throw new CertificateException("Could not build a valid certification path to a trusted root: " + e.getMessage(), e);
        } catch (GeneralSecurityException e) {
            throw new CertificateException("Certificate path validation failed: " + e.getMessage(), e);
        }
    }

    /**
     * Web ã‚µãƒ¼ãƒè¨¼æ˜æ›¸ã¨ã—ã¦ã®æœ€ä½é™ãƒã‚§ãƒƒã‚¯:
     * - ç¾åœ¨æ™‚åˆ»ãŒæœ‰åŠ¹æœŸé–“å†…
     * - KeyUsage: digitalSignature / keyEncipherment ã®ã©ã¡ã‚‰ã‹ï¼ˆRSAï¼‰ã‚„ keyAgreementï¼ˆECDHE ç­‰ï¼‰ã‚’æƒ³å®š
     * - EKU ã« serverAuth ã‚’å«ã‚€ï¼ˆçœç•¥ï¼åˆ¶é™ãªã—ã®å ´åˆã¯è¨±å®¹ï¼‰
     */
    private static void checkEndEntityForTlsServer(X509Certificate cert) throws CertificateException {
        // æœŸé™
        Instant now = Instant.now();
        try {
            cert.checkValidity(Date.from(now));
        } catch (CertificateExpiredException | CertificateNotYetValidException ex) {
            throw new CertificateException("End-entity certificate is not valid now: " + ex.getMessage(), ex);
        }

        // EKUï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆã¯ serverAuth ã‚’è¦æ±‚ï¼‰
        try {
            List<String> eku = cert.getExtendedKeyUsage(); // may be null
            if (eku != null && !eku.contains(EKU_SERVER_AUTH_OID)) {
                throw new CertificateException("End-entity certificate EKU does not include serverAuth.");
            }
        } catch (CertificateParsingException e) {
            throw new CertificateException("Failed to parse Extended Key Usage.", e);
        }

        // KeyUsageï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰
        boolean[] ku = cert.getKeyUsage(); // may be null
        if (ku != null) {
            // digitalSignature(0) or keyEncipherment(2) or keyAgreement(4) ã®ã„ãšã‚Œã‹ã‚’è¨±å®¹
            boolean ok = (ku.length > 0 && ku[0]) || (ku.length > 2 && ku[2]) || (ku.length > 4 && ku[4]);
            if (!ok) {
                throw new CertificateException("End-entity certificate KeyUsage is not suitable for TLS server.");
            }
        }
    }

    // ===== Builder / ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====

    public static final class Builder {
        private final List<KeyStore> customTrustStores = new ArrayList<>();
        private final List<X509Certificate> extraIntermediates = new ArrayList<>();
        private boolean enableRevocation = false;
        private boolean includeSystemDefaultAnchors = true;

        /** æ—¢å®šï¼ˆJRE/OSï¼‰ã®ä¿¡é ¼ã‚¢ãƒ³ã‚«ãƒ¼ã‚’å«ã‚ã‚‹ã‹ï¼ˆæ—¢å®š: trueï¼‰ */
        public Builder includeSystemDefaultAnchors(boolean include) {
            this.includeSystemDefaultAnchors = include;
            return this;
        }

        /** è¿½åŠ ã® TrustStoreï¼ˆJKS/PKCS12 ãªã©ï¼‰ã‚’ä¿¡é ¼ã‚¢ãƒ³ã‚«ãƒ¼ã¨ã—ã¦ä½¿ç”¨ */
        public Builder addTrustStore(KeyStore ks) {
            this.customTrustStores.add(Objects.requireNonNull(ks));
            return this;
        }

        /** AIA å–å¾—ãŒã§ããªã„ç’°å¢ƒãªã©ã§ã€ä¸­é–“ CA ã‚’æ‰‹å‹•æŠ•å…¥ã—ãŸã„å ´åˆã«ä½¿ç”¨ */
        public Builder addIntermediate(X509Certificate intermediate) {
            this.extraIntermediates.add(Objects.requireNonNull(intermediate));
            return this;
        }

        /** OCSP/CRL ã«ã‚ˆã‚‹å¤±åŠ¹ç¢ºèªã‚’æœ‰åŠ¹åŒ–ï¼ˆç’°å¢ƒè¨­å®šãŒå¿…è¦ï¼‰ */
        public Builder enableRevocation(boolean enable) {
            this.enableRevocation = enable;
            return this;
        }

        public ChainValidatingTrustStrategy build() {
            Set<TrustAnchor> anchors = new HashSet<>();
            if (includeSystemDefaultAnchors) {
                anchors.addAll(loadSystemDefaultAnchors());
            }
            for (KeyStore ks : customTrustStores) {
                anchors.addAll(loadAnchorsFromKeyStore(ks));
            }
            if (anchors.isEmpty()) {
                throw new IllegalStateException("No trust anchors configured.");
            }
            return new ChainValidatingTrustStrategy(anchors, extraIntermediates, enableRevocation);
        }
    }

    /** ã‚·ã‚¹ãƒ†ãƒ æ—¢å®šï¼ˆJRE/OSï¼‰ã®ä¿¡é ¼ã‚¢ãƒ³ã‚«ãƒ¼ã‚’æŠ½å‡º */
    private static Set<TrustAnchor> loadSystemDefaultAnchors() {
        try {
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
            tmf.init((KeyStore) null); // ã‚·ã‚¹ãƒ†ãƒ æ—¢å®š
            Set<TrustAnchor> result = new HashSet<>();
            for (TrustManager tm : tmf.getTrustManagers()) {
                if (tm instanceof X509TrustManager) {
                    for (X509Certificate ca : ((X509TrustManager) tm).getAcceptedIssuers()) {
                        result.add(new TrustAnchor(ca, null));
                    }
                }
            }
            return result;
        } catch (GeneralSecurityException e) {
            throw new RuntimeException("Failed to load system default trust anchors: " + e.getMessage(), e);
        }
    }

    /** ä»»æ„ã® KeyStore ã‹ã‚‰ä¿¡é ¼ã‚¢ãƒ³ã‚«ãƒ¼ã‚’æŠ½å‡ºï¼ˆ"trustedCertEntry" ã‚’å¯¾è±¡ï¼‰ */
    private static Set<TrustAnchor> loadAnchorsFromKeyStore(KeyStore ks) {
        try {
            Set<TrustAnchor> result = new HashSet<>();
            for (Enumeration<String> e = ks.aliases(); e.hasMoreElements(); ) {
                String alias = e.nextElement();
                if (ks.isCertificateEntry(alias)) {
                    Certificate c = ks.getCertificate(alias);
                    if (c instanceof X509Certificate) {
                        result.add(new TrustAnchor((X509Certificate) c, null));
                    }
                }
            }
            return result;
        } catch (GeneralSecurityException e) {
            throw new RuntimeException("Failed to read anchors from KeyStore: " + e.getMessage(), e);
        }
    }

    /** å‚è€ƒï¼šKeyStore ãƒ­ãƒ¼ãƒ€ï¼ˆJKS/PKCS12ï¼‰ */
    public static KeyStore loadKeyStore(String type, java.nio.file.Path path, char[] password) {
        try (java.io.InputStream in = java.nio.file.Files.newInputStream(path)) {
            KeyStore ks = KeyStore.getInstance(type); // "JKS" or "PKCS12"
            ks.load(in, password);
            return ks;
        } catch (Exception e) {
            throw new RuntimeException("Failed to load KeyStore: " + e.getMessage(), e);
        }
    }

    /** å‚è€ƒï¼šäººé–“å‘ã‘ãƒ€ãƒ³ãƒ—ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰ */
    public static String describeChain(X509Certificate[] chain) {
        if (chain == null) return "<null>";
        return Arrays.stream(chain)
                .map(c -> String.format("CN=%s, Issuer=%s, Serial=%s",
                        getCN(c.getSubjectX500Principal().getName()),
                        getCN(c.getIssuerX500Principal().getName()),
                        c.getSerialNumber().toString(16)))
                .collect(Collectors.joining(" -> "));
    }

    private static String getCN(String dn) {
        for (String part : dn.split(",")) {
            String p = part.trim();
            if (p.startsWith("CN=")) return p.substring(3);
        }
        return dn;
    }
}
2) HttpClient 5 ã¸ã®çµ„ã¿è¾¼ã¿ä¾‹ï¼ˆHostname æ¤œè¨¼ã‚‚å¿…é ˆï¼‰
import com.example.tls.ChainValidatingTrustStrategy;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClients;
import org.apache.hc.client5.http.ssl.DefaultHostnameVerifier;
import org.apache.hc.core5.ssl.SSLContextBuilder;

import javax.net.ssl.SSLContext;
import java.nio.file.Paths;
import java.security.KeyStore;

public class HttpClientFactory {

    public static CloseableHttpClient create() throws Exception {
        // ä¾‹: è¿½åŠ ã®ç¤¾å†… CA ã‚’ truststore.jks ã‹ã‚‰èª­ã¿è¾¼ã‚€
        KeyStore corpTrust = ChainValidatingTrustStrategy.loadKeyStore(
                "JKS",
                Paths.get("config/truststore.jks"),
                "changeit".toCharArray()
        );

        ChainValidatingTrustStrategy ts = ChainValidatingTrustStrategy.builder()
                .includeSystemDefaultAnchors(true)     // æ—¢å®šã®ãƒ«ãƒ¼ãƒˆ CA ã‚‚è¨±å¯
                .addTrustStore(corpTrust)              // è¿½åŠ ã®ç¤¾å†… CA ã‚’è¨±å¯
                .enableRevocation(false)               // å¿…è¦ã«å¿œã˜ã¦ trueï¼ˆç’°å¢ƒæ§‹ç¯‰ãŒå¿…è¦ï¼‰
                .build();

        SSLContext sslContext = SSLContextBuilder.create()
                // truststore ã¯ null ã§ã‚‚ OKã€‚TrustStrategy ãŒæœ€çµ‚åˆ¤æ–­ã‚’è¡Œã†
                .loadTrustMaterial(null, ts)
                .build();

        return HttpClients.custom()
                .setSSLContext(sslContext)
                .setSSLHostnameVerifier(new DefaultHostnameVerifier()) // â˜… Hostname æ¤œè¨¼ã‚’å¿…ãšæœ‰åŠ¹ã«
                .build();
    }
}
ğŸ“ ãƒã‚¤ãƒ³ãƒˆ

TrustStrategy ã¯ã€Œã“ã®ãƒã‚§ãƒ¼ãƒ³ã‚’ä¿¡é ¼ã™ã‚‹ã‹ã€ã®åˆ¤æ–­ã®ã¿ã€‚ãƒ›ã‚¹ãƒˆåæ¤œè¨¼ï¼ˆSAN/CN ã®ä¸€è‡´ï¼‰ã¯åˆ¥ãªã®ã§ã€DefaultHostnameVerifier ã‚’å¿…ãšè¨­å®šã—ã¦ãã ã•ã„ã€‚

å¤±åŠ¹ç¢ºèªï¼ˆOCSP/CRLï¼‰ã‚’è¡Œã†å ´åˆã¯ enableRevocation(true) ã«åŠ ãˆã¦ã€å®Ÿè¡Œç’°å¢ƒã§ OCSP/CRL ãŒå‚ç…§ã§ãã‚‹ã‚ˆã†ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯/ãƒ—ãƒ­ã‚­ã‚·/ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æ•´å‚™ã—ã¦ãã ã•ã„ï¼ˆä¾‹ï¼š-Dcom.sun.security.enableCRLDP=true -Dcom.sun.net.ssl.checkRevocation=true -Dcom.sun.security.ocsp.enable=true ç­‰ï¼‰ã€‚

ã‚µãƒ¼ãƒãŒ ä¸­é–“ CA ã‚’çœç•¥ã—ã¦ãã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚AIA ã‹ã‚‰ã®è‡ªå‹•å–å¾—ã‚’æœŸå¾…ã§ããªã„ç’°å¢ƒã§ã¯ã€addIntermediate(...) ã«ä¸­é–“è¨¼æ˜æ›¸ã‚’æŠ•å…¥ã—ã¦ãã ã•ã„ã€‚

3) Spring (RestTemplate / WebClient) ã§ä½¿ã†å ´åˆã®ãƒ’ãƒ³ãƒˆ
RestTemplate ãªã‚‰ HttpComponentsClientHttpRequestFactory ã«ä¸Šè¨˜ CloseableHttpClient ã‚’æ¸¡ã™ã€‚

Spring WebClient(Netty) ã‚’ä½¿ã†å ´åˆã¯ Netty ã® SslContextBuilder ã§åŒæ§˜ã®æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯ã‚’è‡ªä½œ TrustManager ã«ç§»æ¤ã—ã¾ã™ï¼ˆNetty ã¯ Apache ã® TrustStrategy ã‚’ç›´æ¥ã¯ä½¿ãˆã¾ã›ã‚“ï¼‰ã€‚

å¿…è¦ãªã‚‰ã€ãƒ”ãƒ³ç•™ã‚ï¼ˆè¨¼æ˜æ›¸/å…¬é–‹éµãƒ”ãƒ³ãƒ‹ãƒ³ã‚°ï¼‰ã‚„ç‰¹å®šã®ä¸­é–“ CA ã®ã¿è¨±å®¹ã¨ã„ã£ãŸãƒãƒªã‚·ãƒ¼ã‚‚ã€ã“ã®ã‚¯ãƒ©ã‚¹ã«ç°¡å˜ã«æ‹¡å¼µã§ãã¾ã™ã€‚
ã“ã®æ–¹é‡ã§å¤§ä¸ˆå¤«ãã†ãªã‚‰ã€ã‚ãªãŸã®ç’°å¢ƒï¼ˆJava / HttpClient ã®ãƒ¡ã‚¸ãƒ£ãƒ¼ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã€Spring ã®æ§‹æˆï¼‰ã«åˆã‚ã›ã¦æœ€é©åŒ–ã—ãŸç‰ˆã‚’ã™ãç”¨æ„ã—ã¾ã™ã€‚

ã‚ãªãŸ:
ã¡ãªã¿ã«ã‚‚ã£ã¨çŸ­ãã§ãã£ãŸã‚Šã—ã¾ã™ã‹ï¼Ÿ
ChatGPT:

æ€è€ƒæ™‚é–“: 1m 7s
ã¯ã„ã€‚æœ€çŸ­ã§â€œå®‰å…¨ãªãƒã‚§ãƒ¼ãƒ³æ¤œè¨¼â€ã«å¯„ã›ã‚‹ãªã‚‰ã€TrustStrategyã®ä¸­ã§ JSSE ã®æ¨™æº– X509TrustManager ã«å§”è­²ã™ã‚‹ã®ãŒã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã§ã™ã€‚
ï¼ˆï¼PKIX ãƒã‚§ãƒ¼ãƒ³æ§‹ç¯‰ãƒ»æ¤œè¨¼ã¯ TrustManagerFactory ãŒå®Ÿæ–½ã€‚Hostname æ¤œè¨¼ã¯åˆ¥é€” DefaultHostnameVerifier ã‚’å¿…ãšä½µç”¨ã€‚ï¼‰

æœ€å°å®Ÿè£…ï¼ˆç´„60è¡Œï¼‰
package com.example.tls;

import org.apache.hc.core5.ssl.TrustStrategy; // HttpClient 5ï¼ˆ4.5ç³»ã¯org.apache.http.ssl.TrustStrategyï¼‰

import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.KeyStore;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

/**
 * ã‚·ã‚¹ãƒ†ãƒ æ—¢å®š + ä»»æ„ã®TrustStore ã® X509TrustManager ã«å§”è­²ã—ã¦
 * ã‚µãƒ¼ãƒè¨¼æ˜æ›¸ãƒã‚§ãƒ¼ãƒ³ã‚’ PKIX ã§æ¤œè¨¼ã™ã‚‹æœ€å°TrustStrategyã€‚
 */
public final class DelegatingTmTrustStrategy implements TrustStrategy {

    private final X509TrustManager sysTm;   // ã‚·ã‚¹ãƒ†ãƒ æ—¢å®š
    private final X509TrustManager extraTm; // è¿½åŠ TrustStoreï¼ˆä»»æ„ã€nullå¯ï¼‰

    private DelegatingTmTrustStrategy(X509TrustManager sysTm, X509TrustManager extraTm) {
        this.sysTm = sysTm;
        this.extraTm = extraTm;
    }

    /** è¿½åŠ ã®TrustStoreï¼ˆJKS/PKCS12ï¼‰ã‚’ä½¿ã„ãŸã„æ™‚ã ã‘æ¸¡ã™ã€‚ä¸è¦ãªã‚‰null */
    public static DelegatingTmTrustStrategy of(KeyStore extraTrustStore) {
        return new DelegatingTmTrustStrategy(
                tmFrom(null),                                // system default anchors
                extraTrustStore != null ? tmFrom(extraTrustStore) : null
        );
    }

    @Override
    public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        try {
            sysTm.checkServerTrusted(chain, authType); // æ—¢å®šã®ä¿¡é ¼ã‚¹ãƒˆã‚¢ã§æ¤œè¨¼ï¼ˆãƒã‚§ãƒ¼ãƒ³æ§‹ç¯‰å«ã‚€ï¼‰
            return true;
        } catch (CertificateException e) {
            if (extraTm != null) {
                // ç¤¾å†…CAãªã©è¿½åŠ TrustStoreã§ã‚‚ã†ä¸€åº¦æ¤œè¨¼
                extraTm.checkServerTrusted(chain, authType);
                return true;
            }
            throw e;
        }
    }

    // ---- helpers ----
    private static X509TrustManager tmFrom(KeyStore ks) {
        try {
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(
                    TrustManagerFactory.getDefaultAlgorithm());
            tmf.init(ks); // null=ã‚·ã‚¹ãƒ†ãƒ æ—¢å®š
            return (X509TrustManager) java.util.Arrays.stream(tmf.getTrustManagers())
                    .filter(tm -> tm instanceof X509TrustManager)
                    .findFirst().orElseThrow(() -> new IllegalStateException("No X509TrustManager"));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /** è¿½åŠ  TrustStore ç”¨ãƒ­ãƒ¼ãƒ€ï¼ˆä¾‹: "JKS" / "PKCS12"ï¼‰ */
    public static KeyStore loadKeyStore(String type, Path path, char[] password) {
        try (InputStream in = Files.newInputStream(path)) {
            KeyStore ks = KeyStore.getInstance(type);
            ks.load(in, password);
            return ks;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
HttpClient 5 ã¸ã®çµ„ã¿è¾¼ã¿ï¼ˆæœ€å°ï¼‰
import com.example.tls.DelegatingTmTrustStrategy;
import org.apache.hc.client5.http.impl.classic.HttpClients;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.ssl.DefaultHostnameVerifier;
import org.apache.hc.core5.ssl.SSLContextBuilder;

import javax.net.ssl.SSLContext;
import java.nio.file.Paths;
import java.security.KeyStore;

public class ClientFactory {
    public static CloseableHttpClient create() throws Exception {
        // è¿½åŠ ã®ç¤¾å†…CAãŒã‚ã‚‹å ´åˆã ã‘èª­ã¿è¾¼ã‚€ï¼ˆç„¡ã‘ã‚Œã° extraKs = nullï¼‰
        KeyStore extraKs = DelegatingTmTrustStrategy.loadKeyStore(
                "JKS", Paths.get("config/truststore.jks"), "changeit".toCharArray());

        SSLContext ssl = SSLContextBuilder.create()
                .loadTrustMaterial(null, DelegatingTmTrustStrategy.of(extraKs))
                .build();

        return HttpClients.custom()
                .setSSLContext(ssl)
                .setSSLHostnameVerifier(new DefaultHostnameVerifier()) // â˜…å¿…é ˆï¼šãƒ›ã‚¹ãƒˆåæ¤œè¨¼
                .build();
    }
}
è£œè¶³ï¼ˆçŸ­ã•å„ªå…ˆã®ä»£ã‚ã‚Šã«çœã„ãŸã‚‚ã®ï¼‰
EKU(KeyUsage)ã‚„å¤±åŠ¹ç¢ºèª(OCSP/CRL)ã®è¿½åŠ ãƒã‚§ãƒƒã‚¯ã¯å‰²æ„›ã€‚å¿…è¦ãªã‚‰å‰å›æ¡ˆã®ã‚ˆã†ã«æ‹¡å¼µã—ã¦ãã ã•ã„ã€‚

AIA ã‹ã‚‰ã®ä¸­é–“CAå–å¾—ã«é ¼ã‚‰ãšç¢ºå®Ÿã«é€šã—ãŸã„å ´åˆã¯ã€ä¸­é–“CAã‚’ truststore ã«å…¥ã‚Œã¦ãã ã•ã„ã€‚

ã“ã®å½¢ãªã‚‰ã€ãƒã‚§ãƒ¼ãƒ³æ¤œè¨¼ã¯ TrustManager ã«ä¸¸æŠ•ã’ã§ãã€ã‚³ãƒ¼ãƒ‰é‡ã‚’æœ€å°åŒ–ã—ã¤ã¤ã€Œã‚·ã‚¹ãƒ†ãƒ æ—¢å®šï¼‹è¿½åŠ TrustStoreã€ã«ã‚‚å¯¾å¿œã§ãã¾ã™ã€‚

ã‚ãªãŸ:
ã§ãã‚Œã°ã€ä½•ã‚’ã‚„ã£ã¦ã„ã‚‹ã‹ã‚³ãƒ¼ãƒ‰ä¸Šã«ã‚³ãƒ¡ãƒ³ãƒˆã‚’æ›¸ã„ã¦æ¬²ã—ã„ã®ã§ã™ãŒå¯èƒ½ã§ã™ã‹ã€‚
ChatGPT:

æ€è€ƒæ™‚é–“: 16s
ã‚‚ã¡ã‚ã‚“ã§ã™ã€‚æœ€å°æ§‹æˆï¼‹è¦ç‚¹ã«çµã£ãŸæ—¥æœ¬èªã‚³ãƒ¡ãƒ³ãƒˆå…¥ã‚Šã§ç”¨æ„ã—ã¾ã—ãŸã€‚
ï¼ˆHttpClient 5 ç³»æƒ³å®šã€‚4.5 ç³»ãªã‚‰ org.apache.http.ssl.TrustStrategy ã«ç½®ãæ›ãˆã¦ãã ã•ã„ï¼‰

1) TrustStrategy å®Ÿè£…ï¼ˆãƒã‚§ãƒ¼ãƒ³æ¤œè¨¼ã¯æ¨™æº– TrustManager ã«å§”è­²ï¼‰
package com.example.tls;

import org.apache.hc.core5.ssl.TrustStrategy; // HttpClient 5 ç³»
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.KeyStore;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

/**
 * DelegatingTmTrustStrategy
 *
 * ç›®çš„:
 * - ã‚µãƒ¼ãƒãŒæç¤ºã—ãŸè¨¼æ˜æ›¸ãƒã‚§ãƒ¼ãƒ³ã®æ¤œè¨¼ã‚’ã€æ¨™æº–ã® PKIX å®Ÿè£…(X509TrustManager)ã«å§”è­²ã—ã¦è¡Œã†ã€‚
 * - ã€Œã‚·ã‚¹ãƒ†ãƒ æ—¢å®šã®ä¿¡é ¼ã‚¹ãƒˆã‚¢ï¼ˆOS/JREï¼‰ã€ã«åŠ ãˆã€å¿…è¦ã«å¿œã˜ã¦ã€Œç¤¾å†…CAãªã©ã®è¿½åŠ  TrustStoreã€ã§ã‚‚æ¤œè¨¼ã™ã‚‹ã€‚
 *
 * ãƒã‚¤ãƒ³ãƒˆ:
 * - è¨¼æ˜æ›¸ãƒã‚§ãƒ¼ãƒ³ã®æ§‹ç¯‰/ç½²åæ¤œè¨¼/æœ‰åŠ¹æœŸé™ãªã©ã¯ TrustManagerFactory ã«ä»»ã›ã‚‹ã®ã§å®Ÿè£…ãŒçŸ­ã„ã€‚
 * - Hostname æ¤œè¨¼ã¯ TrustStrategy ã®å½¹å‰²å¤–ã€‚HttpClient å´ã§ DefaultHostnameVerifier ã‚’å¿…ãšæœ‰åŠ¹ã«ã™ã‚‹ã“ã¨ã€‚
 */
public final class DelegatingTmTrustStrategy implements TrustStrategy {

    // ã‚·ã‚¹ãƒ†ãƒ æ—¢å®šã®ä¿¡é ¼ã‚¢ãƒ³ã‚«ãƒ¼ã‹ã‚‰ä½œã£ãŸ X509TrustManager
    private final X509TrustManager systemTm;

    // è¿½åŠ ã® TrustStoreï¼ˆä»»æ„ï¼‰ã€‚ç¤¾å†…CAãªã©ã‚’å…¥ã‚Œã¦ãŠãã¨ã€ã“ã“ã§ã‚‚ã†ä¸€åº¦æ¤œè¨¼ã§ãã‚‹
    private final X509TrustManager extraTm;

    private DelegatingTmTrustStrategy(X509TrustManager systemTm, X509TrustManager extraTm) {
        this.systemTm = systemTm;
        this.extraTm = extraTm;
    }

    /**
     * ãƒ•ã‚¡ã‚¯ãƒˆãƒª:
     *   - extraTrustStore ãŒ null ã®å ´åˆã¯ã€Œã‚·ã‚¹ãƒ†ãƒ æ—¢å®šã®ã¿ã€ã§æ¤œè¨¼
     *   - æ¸¡ã•ã‚ŒãŸå ´åˆã¯ã€Œã‚·ã‚¹ãƒ†ãƒ æ—¢å®š â†’ ãƒ€ãƒ¡ãªã‚‰è¿½åŠ  TrustStoreã€ã®é †ã§æ¤œè¨¼
     */
    public static DelegatingTmTrustStrategy of(KeyStore extraTrustStore) {
        return new DelegatingTmTrustStrategy(
                tmFrom(null),                                // null ã‚’æ¸¡ã™ã¨ã‚·ã‚¹ãƒ†ãƒ æ—¢å®šã®ä¿¡é ¼ã‚¹ãƒˆã‚¢ã‚’ä½¿ç”¨
                (extraTrustStore != null) ? tmFrom(extraTrustStore) : null
        );
    }

    /**
     * TrustStrategy ã®æœ¬ä½“ã€‚
     * HttpClient ãŒ TLS ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã§å—ã‘å–ã£ãŸã‚µãƒ¼ãƒè¨¼æ˜æ›¸ãƒã‚§ãƒ¼ãƒ³ã¨ authType ã‚’æ¸¡ã—ã¦ãã‚‹ã€‚
     *
     * ã“ã“ã§ã¯:
     *  1) ã¾ãšã‚·ã‚¹ãƒ†ãƒ æ—¢å®šã® TrustManager ã§ã€Œã‚µãƒ¼ãƒç”¨ã®ãƒã‚§ãƒ¼ãƒ³ã€ã¨ã—ã¦æ¤œè¨¼
     *  2) ãã‚Œã§ãƒ€ãƒ¡ãªã‚‰ã€è¿½åŠ  TrustStoreï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰ã§å†æ¤œè¨¼
     *  3) ä¸¡æ–¹ãƒ€ãƒ¡ãªã‚‰ä¿¡é ¼ä¸å¯ï¼ˆä¾‹å¤–æŠ•ã’ã‚‹ï¼‰
     *
     * æˆ»ã‚Šå€¤ true ã®æ„å‘³:
     *  - ã€Œä¿¡é ¼ã§ãã‚‹ã€ï¼ã€Œãƒ«ãƒ¼ãƒˆã¾ã§ã®èªè¨¼çµŒè·¯ãŒæ­£ã—ãæ§‹ç¯‰ã§ãã€ç½²åã‚„æœŸé™ãªã© PKIX æ¤œè¨¼ã«åˆæ ¼ã—ãŸã€
     */
    @Override
    public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        try {
            // ã‚·ã‚¹ãƒ†ãƒ æ—¢å®šã®ã‚¢ãƒ³ã‚«ãƒ¼ã«å¯¾ã—ã¦ PKIX æ¤œè¨¼ï¼ˆä¸­é–“ãŒä¸€éƒ¨è¶³ã‚Šãªã„å ´åˆã‚‚ã€AIA å–å¾—ãªã©ã§è£œå®Œã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚‹ï¼‰
            systemTm.checkServerTrusted(chain, authType);
            return true;
        } catch (CertificateException first) {
            // ã‚·ã‚¹ãƒ†ãƒ æ—¢å®šã§å¤±æ•—ã€‚è¿½åŠ  TrustStore ãŒã‚ã‚Œã°å†ãƒˆãƒ©ã‚¤
            if (extraTm != null) {
                extraTm.checkServerTrusted(chain, authType); // ã“ã“ã§é€šã‚Œã°ä¿¡é ¼OK
                return true;
            }
            // ã©ã¡ã‚‰ã§ã‚‚é€šã‚‰ãªã„å ´åˆã¯æ¤œè¨¼å¤±æ•—ã¨ã—ã¦æŠ•ã’ç›´ã™
            throw first;
        }
    }

    // === ãƒ˜ãƒ«ãƒ‘ ===

    /**
     * ä»»æ„ã® KeyStore ã‹ã‚‰ X509TrustManager ã‚’ä½œã‚‹ã€‚
     * - ks == null ã®å ´åˆ: ã‚·ã‚¹ãƒ†ãƒ æ—¢å®šã®ä¿¡é ¼ã‚¢ãƒ³ã‚«ãƒ¼é›†åˆã‚’ä½¿ã†
     * - ks != null ã®å ´åˆ: æ¸¡ã•ã‚ŒãŸ TrustStoreï¼ˆJKS/PKCS12 ç­‰ï¼‰ã«å…¥ã£ã¦ã„ã‚‹ã€Œä¿¡é ¼ã§ãã‚‹è¨¼æ˜æ›¸ã€ã‚’ã‚¢ãƒ³ã‚«ãƒ¼ã«ã™ã‚‹
     */
    private static X509TrustManager tmFrom(KeyStore ks) {
        try {
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(
                    TrustManagerFactory.getDefaultAlgorithm());
            tmf.init(ks); // null ã§åˆæœŸåŒ–ã™ã‚‹ã¨ã‚·ã‚¹ãƒ†ãƒ æ—¢å®šã‚’ä½¿ç”¨
            return (X509TrustManager) java.util.Arrays.stream(tmf.getTrustManagers())
                    .filter(tm -> tm instanceof X509TrustManager)
                    .findFirst()
                    .orElseThrow(() -> new IllegalStateException("No X509TrustManager available"));
        } catch (Exception e) {
            throw new RuntimeException("Failed to create X509TrustManager", e);
        }
    }

    /**
     * è¿½åŠ  TrustStore ãƒ­ãƒ¼ãƒ€ï¼ˆJKS/PKCS12 ãªã©ï¼‰ã€‚
     * ä¾‹:
     *   KeyStore ks = loadKeyStore("JKS", Paths.get("config/truststore.jks"), "changeit".toCharArray());
     */
    public static KeyStore loadKeyStore(String type, Path path, char[] password) {
        try (InputStream in = Files.newInputStream(path)) {
            KeyStore ks = KeyStore.getInstance(type); // "JKS" or "PKCS12"
            ks.load(in, password);
            return ks;
        } catch (Exception e) {
            throw new RuntimeException("Failed to load KeyStore: " + path, e);
        }
    }
}
2) HttpClient5 ã¸ã®çµ„ã¿è¾¼ã¿ä¾‹ï¼ˆHostname æ¤œè¨¼ã®æœ‰åŠ¹åŒ–ã‚’å«ã‚€ï¼‰
import com.example.tls.DelegatingTmTrustStrategy;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClients;
import org.apache.hc.client5.http.ssl.DefaultHostnameVerifier; // â˜… ãƒ›ã‚¹ãƒˆåæ¤œè¨¼ç”¨
import org.apache.hc.core5.ssl.SSLContextBuilder;

import javax.net.ssl.SSLContext;
import java.nio.file.Paths;
import java.security.KeyStore;

public class ClientFactory {

    public static CloseableHttpClient create() throws Exception {
        // 1) è¿½åŠ ã®ç¤¾å†… CA ã‚’ truststore ã‹ã‚‰èª­ã¿è¾¼ã¿ï¼ˆä¸è¦ãªã‚‰ null ã‚’æ¸¡ã™ï¼‰
        //    - truststore ã«ã¯ã€Œä¿¡é ¼ã—ãŸã„ä¸­é–“/ãƒ«ãƒ¼ãƒˆ CAï¼ˆtrustedCertEntryï¼‰ã€ã‚’å…¥ã‚Œã¦ãŠã
        KeyStore extraKs = DelegatingTmTrustStrategy.loadKeyStore(
                "JKS", Paths.get("config/truststore.jks"), "changeit".toCharArray()
        );

        // 2) TrustStrategy ã‚’ SSLContext ã«çµ„ã¿è¾¼ã‚€
        SSLContext sslContext = SSLContextBuilder.create()
                // KeyStore å¼•æ•°ã¯ nullï¼ˆï¼ã“ã“ã§ã¯å›ºå®š truststore ã‚’æŒãŸãªã„ï¼‰ã€‚
                // æœ€çµ‚åˆ¤æ–­ã¯ TrustStrategy å´ã§å®Ÿæ–½ï¼ˆï¼å†…éƒ¨ã® TrustManager ã«å§”è­²ï¼‰
                .loadTrustMaterial(null, DelegatingTmTrustStrategy.of(extraKs))
                .build();

        // 3) HttpClient ã‚’æ§‹ç¯‰
        return HttpClients.custom()
                .setSSLContext(sslContext)
                // â˜… é‡è¦ï¼šHostname æ¤œè¨¼ã¯ TrustStrategy ã®ç¯„å›²å¤–ã€‚ã“ã“ã§å¿…ãšæœ‰åŠ¹åŒ–ã™ã‚‹ã€‚
                //    - ã‚µãƒ¼ãƒè¨¼æ˜æ›¸ã® SAN/CN ã¨æ¥ç¶šå…ˆãƒ›ã‚¹ãƒˆåã®ä¸€è‡´ã‚’æ¤œè¨¼
                .setSSLHostnameVerifier(new DefaultHostnameVerifier())
                .build();
    }
}
é‹ç”¨ãƒ¡ãƒ¢ï¼ˆã‚ˆãã‚ã‚‹ãƒã‚¤ãƒ³ãƒˆï¼‰
ä¸­é–“ CA ãŒã‚µãƒ¼ãƒã‹ã‚‰é€ã‚‰ã‚Œã¦ã“ãªã„ç’°å¢ƒã§ã¯ã€truststore.jks ã«ä¸­é–“ CA ã‚’å…¥ã‚Œã¦ãŠãã¨å®‰å®šã—ã¾ã™ï¼ˆAIA å–å¾—ã«é ¼ã‚‰ãªã„ï¼‰ã€‚

**å¤±åŠ¹ç¢ºèªï¼ˆOCSP/CRLï¼‰**ã¾ã§ã‚„ã‚ŠãŸã„å ´åˆã¯ã€TrustStrategy ã§ã¯ãªã JVM å…¨ä½“ã® revocation è¨­å®šã‚’æœ‰åŠ¹ã«ã™ã‚‹ã®ãŒç°¡å˜ã§ã™ï¼š
ä¾‹ï¼‰-Dcom.sun.net.ssl.checkRevocation=true -Dcom.sun.security.enableCRLDP=true -Dcom.sun.security.ocsp.enable=true
ï¼ˆãƒ—ãƒ­ã‚­ã‚·è¨­å®šãƒ»OCSP/CRL ã¸ã®åˆ°é”æ€§ãªã©ç’°å¢ƒæ•´å‚™ãŒåˆ¥é€”å¿…è¦ï¼‰

HttpClient 4.5 ç³»ã‚’ä½¿ã†å ´åˆã¯ã€import org.apache.http.ssl.TrustStrategy; ã«å¤‰ãˆã‚‹ã ã‘ã§æ¦‚ã­åŒã˜ç™ºæƒ³ã§å‹•ãã¾ã™ã€‚

å¿…è¦ãªã‚‰ã€ã“ã®æœ€å°ç‰ˆã« EKU(serverAuth) / KeyUsage ã®è¿½åŠ ãƒã‚§ãƒƒã‚¯ã‚„ã€ç‰¹å®š CA ã®ã¿è¨±å®¹ï¼ˆãƒ”ãƒ³ãƒ‹ãƒ³ã‚°ç›¸å½“ï¼‰ãªã©ã‚‚ã‚³ãƒ¡ãƒ³ãƒˆä»˜ãã§æ‹¡å¼µã—ã¾ã™ã€‚

ã‚ãªãŸ:
ã“ã®æœ€å°ã‚³ãƒ¼ãƒ‰ã¯ã€è¨¼æ˜æ›¸ãƒã‚§ãƒ¼ãƒ³ä»¥å¤–ã®æ¤œè¨¼ã‚‚è¡Œãˆã¦ã„ã¾ã™ã‹ï¼Ÿ
ã¾ãŸã€å˜æ–¹å‘ãƒ»åŒæ–¹å‘ã®åˆ‡ã‚Šæ›¿ãˆãŒã§ãã‚‹ã‚ˆã†ã«ã—ã¦ã»ã—ã„ã®ã§ã™ãŒã€å¯èƒ½ã§ã—ã‚‡ã†ã‹ã€‚
ChatGPT:

æ€è€ƒæ™‚é–“: 59s
ã„ã„è³ªå•ã§ã™ã€‚ã¾ãšçµè«–ã‹ã‚‰ï¼š

1) ã“ã®æœ€å°ã‚³ãƒ¼ãƒ‰ãŒè¡Œã£ã¦ã„ã‚‹ã€Œãƒã‚§ãƒ¼ãƒ³ä»¥å¤–ã®æ¤œè¨¼ã€
checkServerTrusted(...) ã‚’ä½¿ã£ã¦ã„ã‚‹ãŸã‚ JSSE ã® PKIX æ¤œè¨¼ãŒæœ‰åŠ¹ã§ã™ã€‚ã¤ã¾ã‚Šâ€”â€”

âœ… ç½²åé€£é–ï¼ˆãƒ«ãƒ¼ãƒˆã¾ã§ã®çµŒè·¯æ§‹ç¯‰ã¨æ¤œè¨¼ï¼‰

âœ… æœ‰åŠ¹æœŸé™ãƒã‚§ãƒƒã‚¯ï¼ˆæœŸé™åˆ‡ã‚Œï¼æœªæœ‰åŠ¹ï¼‰

âœ… BasicConstraints / CA ã‹ã©ã†ã‹ï¼ˆä¸­é–“ã¯ CA å¿…é ˆï¼‰

âœ… KeyUsage / ExtendedKeyUsage
EKU ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ serverAuth ã‚’å«ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼ˆç„¡æŒ‡å®šï¼åˆ¶é™ãªã—ã¯è¨±å®¹ï¼‰ã€‚
KeyUsage ã¯ã‚¹ã‚¤ãƒ¼ãƒˆã«å¿œã˜ã¦ digitalSignature / keyEncipherment / keyAgreement ã®é©åˆãŒæ±‚ã‚ã‚‰ã‚Œã¾ã™ã€‚

âœ… ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ åˆ¶é™ï¼ˆjdk.certpath.disabledAlgorithms ãªã©ã® JDK è¨­å®šã«å¾“ã†ï¼‰

â›” å«ã¾ã‚Œãªã„ã‚‚ã®

ãƒ›ã‚¹ãƒˆåæ¤œè¨¼ï¼ˆSAN/CN ã¨æ¥ç¶šå…ˆãƒ›ã‚¹ãƒˆåã®ä¸€è‡´ï¼‰â†’ DefaultHostnameVerifier ã§å¿…ãšå®Ÿæ–½

å¤±åŠ¹ç¢ºèªï¼ˆOCSP/CRLï¼‰ â†’ æ—¢å®šã¯ç„¡åŠ¹ã€‚å¿…è¦ãªã‚‰ JVM ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã§æœ‰åŠ¹åŒ–
ä¾‹ï¼š-Dcom.sun.net.ssl.checkRevocation=true -Dcom.sun.security.enableCRLDP=true -Dcom.sun.security.ocsp.enable=true

2) å˜æ–¹å‘ / åŒæ–¹å‘ï¼ˆmTLSï¼‰ã®åˆ‡ã‚Šæ›¿ãˆå¯¾å¿œç‰ˆ
å˜æ–¹å‘ TLSï¼ˆã‚µãƒ¼ãƒè¨¼æ˜æ›¸ã®ã¿æ¤œè¨¼ï¼‰â€¦å¾“æ¥ã©ãŠã‚Š TrustStrategy + HostnameVerifier

åŒæ–¹å‘ TLS (mTLS) â€¦ä¸Šã« ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆè¨¼æ˜æ›¸ï¼ˆKeyManagerï¼‰ ã‚’è¿½åŠ ã—ã¦åˆ‡ã‚Šæ›¿ãˆ

ä¸‹ã¯ çŸ­ã•å„ªå…ˆï¼‹æ—¥æœ¬èªã‚³ãƒ¡ãƒ³ãƒˆå…¥ã‚Šã®å®Ÿè£…ã§ã™ã€‚

A) TrustStrategyï¼ˆé †ç•ªã¨ã‚¢ãƒ³ã‚«ãƒ¼ç¯„å›²ã‚‚åˆ‡æ›¿å¯èƒ½ï¼‰
package com.example.tls;

import org.apache.hc.core5.ssl.TrustStrategy;

import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.KeyStore;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

/**
 * ç›®çš„:
 *  - ã‚µãƒ¼ãƒãŒæç¤ºã—ãŸè¨¼æ˜æ›¸ãƒã‚§ãƒ¼ãƒ³ã® PKIX æ¤œè¨¼ã‚’æ¨™æº– X509TrustManager ã«å§”è­²
 *  - ã€Œã‚·ã‚¹ãƒ†ãƒ æ—¢å®šã‚¢ãƒ³ã‚«ãƒ¼ã€ã¨ã€Œè¿½åŠ  TrustStoreã€ã‚’é †ç•ªä»˜ãã§ä½¿ã„åˆ†ã‘å¯èƒ½
 *
 * æ³¨æ„:
 *  - Hostname æ¤œè¨¼ã¯åˆ¥ï¼ˆHttpClient å´ã§ DefaultHostnameVerifier ã‚’è¨­å®šï¼‰
 *  - å¤±åŠ¹ç¢ºèªã¯ JVM å…¨ä½“ã®è¨­å®šã§æœ‰åŠ¹åŒ–ï¼ˆTrustStrategy ã§ã¯è¡Œã‚ãªã„ï¼‰
 */
public final class DelegatingTmTrustStrategy implements TrustStrategy {

    // 1st ãƒˆãƒ©ã‚¤ç”¨ TrustManagerï¼ˆä¾‹: ã‚·ã‚¹ãƒ†ãƒ æ—¢å®š or è¿½åŠ  TrustStoreï¼‰
    private final X509TrustManager primary;

    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ï¼ˆä»»æ„ã€null å¯ï¼‰
    private final X509TrustManager secondary;

    private DelegatingTmTrustStrategy(X509TrustManager primary, X509TrustManager secondary) {
        this.primary = primary;
        this.secondary = secondary;
    }

    /** ã‚·ã‚¹ãƒ†ãƒ æ—¢å®š â†’ è¿½åŠ TrustStore ã®é †ï¼ˆä¸€èˆ¬çš„ãªæ§‹æˆï¼‰ */
    public static DelegatingTmTrustStrategy ofSystemThenExtra(KeyStore extraTrustStore) {
        return new DelegatingTmTrustStrategy(tmFrom(null),
                extraTrustStore != null ? tmFrom(extraTrustStore) : null);
    }

    /** è¿½åŠ TrustStore ã®ã¿ï¼ˆç¤¾å†… PKI ã ã‘ã‚’ä¿¡é ¼ã—ãŸã„å ´åˆï¼‰ */
    public static DelegatingTmTrustStrategy ofExtraOnly(KeyStore extraTrustStore) {
        if (extraTrustStore == null) throw new IllegalArgumentException("extraTrustStore required");
        return new DelegatingTmTrustStrategy(tmFrom(extraTrustStore), null);
    }

    /** è¿½åŠ TrustStore â†’ ã‚·ã‚¹ãƒ†ãƒ æ—¢å®š ã®é †ï¼ˆç¤¾å†… CA ã‚’å„ªå…ˆã—ãŸã„å ´åˆï¼‰ */
    public static DelegatingTmTrustStrategy ofExtraThenSystem(KeyStore extraTrustStore) {
        if (extraTrustStore == null) throw new IllegalArgumentException("extraTrustStore required");
        return new DelegatingTmTrustStrategy(tmFrom(extraTrustStore), tmFrom(null));
    }

    @Override
    public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        try {
            // ã¾ãš primaryï¼ˆä¾‹: ã‚·ã‚¹ãƒ†ãƒ æ—¢å®šï¼‰ã§æ¤œè¨¼
            primary.checkServerTrusted(chain, authType);
            return true;
        } catch (CertificateException e) {
            // ãƒ€ãƒ¡ãªã‚‰ secondaryï¼ˆä¾‹: è¿½åŠ  TrustStoreï¼‰ã§å†ãƒˆãƒ©ã‚¤
            if (secondary != null) {
                secondary.checkServerTrusted(chain, authType);
                return true;
            }
            throw e;
        }
    }

    // --- ãƒ˜ãƒ«ãƒ‘ ---

    /** ks == null ãªã‚‰ã‚·ã‚¹ãƒ†ãƒ æ—¢å®šã‚¢ãƒ³ã‚«ãƒ¼ã‹ã‚‰ TM ã‚’ä½œæˆã€ãã†ã§ãªã‘ã‚Œã° ks ã‚’ã‚¢ãƒ³ã‚«ãƒ¼ã« TM ã‚’ä½œæˆ */
    private static X509TrustManager tmFrom(KeyStore ks) {
        try {
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(
                    TrustManagerFactory.getDefaultAlgorithm());
            tmf.init(ks); // null â†’ ã‚·ã‚¹ãƒ†ãƒ æ—¢å®š
            return (X509TrustManager) java.util.Arrays.stream(tmf.getTrustManagers())
                    .filter(tm -> tm instanceof X509TrustManager)
                    .findFirst()
                    .orElseThrow(() -> new IllegalStateException("No X509TrustManager available"));
        } catch (Exception e) {
            throw new RuntimeException("Failed to create X509TrustManager", e);
        }
    }

    /** TrustStore ãƒ­ãƒ¼ãƒ€ï¼ˆJKS/PKCS12 ãªã©ï¼‰ */
    public static KeyStore loadKeyStore(String type, Path path, char[] password) {
        try (InputStream in = Files.newInputStream(path)) {
            KeyStore ks = KeyStore.getInstance(type);
            ks.load(in, password);
            return ks;
        } catch (Exception e) {
            throw new RuntimeException("Failed to load KeyStore: " + path, e);
        }
    }
}
B) HttpClient å·¥å ´ï¼ˆå˜æ–¹å‘ï¼åŒæ–¹å‘ã‚’åˆ‡æ›¿ï¼‰
package com.example.tls;

import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClients;
import org.apache.hc.client5.http.ssl.DefaultHostnameVerifier; // â˜…ãƒ›ã‚¹ãƒˆåæ¤œè¨¼
import org.apache.hc.core5.ssl.SSLContextBuilder;
import org.apache.hc.core5.ssl.PrivateKeyStrategy;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLContext;
import java.net.Socket;
import java.nio.file.Paths;
import java.security.KeyStore;
import java.util.Map;

/**
 * å˜æ–¹å‘ï¼ˆã‚µãƒ¼ãƒèªè¨¼ã®ã¿ï¼‰/ åŒæ–¹å‘ï¼ˆmTLSï¼‰ã®åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ãª HttpClient ãƒ•ã‚¡ã‚¯ãƒˆãƒªã€‚
 */
public final class TlsHttpClientFactory {

    public enum Mode { ONE_WAY, MUTUAL } // å˜æ–¹å‘ / åŒæ–¹å‘

    /**
     * @param mode                 ONE_WAY or MUTUAL
     * @param trustStrategy        ã‚µãƒ¼ãƒæ¤œè¨¼ç”¨ã® TrustStrategyï¼ˆä¸Šè¨˜ DelegatingTmTrustStrategyï¼‰
     * @param clientKeyStore       MUTUAL æ™‚ã®ã¿å¿…é ˆï¼ˆPKCS12/JKS ã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆè¨¼æ˜æ›¸ï¼‹ç§˜å¯†éµï¼‰
     * @param clientKeyPassword    ä¸Šè¨˜ã®éµãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼ˆéµã¨ã‚¹ãƒˆã‚¢ãŒåŒã˜ãªã‚‰åŒä¸€ãƒ‘ã‚¹å¯ï¼‰
     * @param clientKeyAlias       è¤‡æ•°ã‚¨ã‚¤ãƒªã‚¢ã‚¹ãŒã‚ã‚‹å ´åˆã®é¸æŠï¼ˆnull ãªã‚‰ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆé¸æŠï¼‰
     * @param hostnameVerifier     null ã®å ´åˆã¯ DefaultHostnameVerifier ã‚’ä½¿ç”¨
     */
    public static CloseableHttpClient create(
            Mode mode,
            DelegatingTmTrustStrategy trustStrategy,
            KeyStore clientKeyStore,
            char[] clientKeyPassword,
            String clientKeyAlias,
            HostnameVerifier hostnameVerifier
    ) throws Exception {

        SSLContextBuilder b = SSLContextBuilder.create()
                // TrustStrategy ã«æœ€çµ‚åˆ¤æ–­ã‚’å§”è­²ï¼ˆJVM æ—¢å®š + è¿½åŠ  TrustStore ãªã©ï¼‰
                .loadTrustMaterial(null, trustStrategy);

        if (mode == Mode.MUTUAL) {
            if (clientKeyStore == null || clientKeyPassword == null) {
                throw new IllegalArgumentException("clientKeyStore/clientKeyPassword required for MUTUAL");
            }
            if (clientKeyAlias == null) {
                // å˜ä¸€éµ or æ—¢å®šéµãªã‚‰ãã®ã¾ã¾
                b.loadKeyMaterial(clientKeyStore, clientKeyPassword);
            } else {
                // æŒ‡å®šã‚¨ã‚¤ãƒªã‚¢ã‚¹ã‚’é¸ã¶å ´åˆï¼ˆè¤‡æ•°éµãŒå…¥ã£ã¦ã„ã‚‹ PKCS12/JKS ã‚’æƒ³å®šï¼‰
                PrivateKeyStrategy pickAlias = (aliases, socket) -> {
                    // å¼•æ•° aliases: Map<alias, PrivateKeyDetails>
                    return aliases.containsKey(clientKeyAlias) ? clientKeyAlias : null;
                };
                b.loadKeyMaterial(clientKeyStore, clientKeyPassword, pickAlias);
            }
        }

        SSLContext ssl = b.build();

        return HttpClients.custom()
                .setSSLContext(ssl)
                .setSSLHostnameVerifier(hostnameVerifier != null ? hostnameVerifier : new DefaultHostnameVerifier())
                .build();
    }

    // --- ä½¿ç”¨ä¾‹ ---

    public static CloseableHttpClient exampleOneWay() throws Exception {
        // è¿½åŠ ã®ç¤¾å†… CA ã‚’èª­ã‚€ï¼ˆä¸è¦ãªã‚‰ null ã§ã‚‚å¯ï¼‰
        KeyStore extra = DelegatingTmTrustStrategy.loadKeyStore(
                "JKS", Paths.get("config/truststore.jks"), "changeit".toCharArray());

        DelegatingTmTrustStrategy ts = DelegatingTmTrustStrategy.ofSystemThenExtra(extra);

        return create(Mode.ONE_WAY, ts, null, null, null, null);
    }

    public static CloseableHttpClient exampleMutual() throws Exception {
        // è¿½åŠ ã®ç¤¾å†… CAï¼ˆå¿…è¦æ™‚ã®ã¿ï¼‰
        KeyStore extra = DelegatingTmTrustStrategy.loadKeyStore(
                "JKS", Paths.get("config/truststore.jks"), "changeit".toCharArray());
        DelegatingTmTrustStrategy ts = DelegatingTmTrustStrategy.ofSystemThenExtra(extra);

        // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆè¨¼æ˜æ›¸ï¼ˆPKCS12 æ¨å¥¨ï¼‰
        KeyStore clientKs = DelegatingTmTrustStrategy.loadKeyStore(
                "PKCS12", Paths.get("secrets/client.p12"), "p12pass".toCharArray());

        return create(Mode.MUTUAL, ts, clientKs, "p12pass".toCharArray(), null, null);
    }
}
ä½¿ã„åˆ†ã‘ã®æŒ‡é‡
å…¬é–‹ã‚µã‚¤ãƒˆå‘ã‘ï¼šofSystemThenExtra(...)ï¼ˆã‚·ã‚¹ãƒ†ãƒ æ—¢å®š â†’ è¿½åŠ  CAï¼‰

ç¤¾å†… PKI ã®ã¿ä¿¡é ¼ï¼šofExtraOnly(...)ï¼ˆå…¬é–‹ CA ã‚’ç„¡åŠ¹åŒ–ï¼‰

ç¤¾å†… CA ã‚’å„ªå…ˆï¼šofExtraThenSystem(...)

mTLS ã‚’ä½¿ã†ï¼šã‚µãƒ¼ãƒå´ã§ã€Œã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆè¨¼æ˜æ›¸å¿…é ˆ or è¦æ±‚ã€ã‚’æœ‰åŠ¹åŒ–ã—ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã« loadKeyMaterial(...) ã‚’è¨­å®š

âœ… ã™ã¹ã¦ã®ãƒ¢ãƒ¼ãƒ‰ã§ Hostname æ¤œè¨¼ã¯å¿˜ã‚Œãšã«ï¼ˆDefaultHostnameVerifierï¼‰ã€‚
ğŸ” å¤±åŠ¹ç¢ºèªãŒå¿…è¦ãªã‚‰ JVM ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã§æœ‰åŠ¹åŒ–ã—ã¦ãã ã•ã„ï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åˆ°é”æ€§ãƒ»ãƒ—ãƒ­ã‚­ã‚·è¨­å®šã‚‚è¦ç¢ºèªï¼‰ã€‚

å¿…è¦ãªã‚‰ã€**EKU(serverAuth) ã‚„ç‰¹å®š CA ã®ã¿è¨±å®¹ï¼ˆãƒ”ãƒ³ãƒ‹ãƒ³ã‚°ç›¸å½“ï¼‰**ã¨ã„ã£ãŸè¿½åŠ ãƒ«ãƒ¼ãƒ«ã‚‚ã“ã®æ§‹æˆã«è–„ãè¶³ã›ã¾ã™ã€‚ã‚ãªãŸã® Spring/Gradle ç’°å¢ƒã«åˆã‚ã›ãŸãƒ†ãƒ³ãƒ—ãƒ¬åŒ–ï¼ˆãƒ—ãƒ­ãƒ‘ãƒ†ã‚£é§†å‹•ã®åˆ‡æ›¿ï¼‰ã‚‚ã™ãå‡ºã—ã¾ã™ã€‚

ã‚ãªãŸ:
Javaã¯21ã‚’ä½¿ã£ã¦ã„ã‚‹ã®ã§ã™ãŒã€checkServerTrustedã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã®ã‚ˆã†ã«è¦‹ãˆã¾ã™ã€‚X509ExtendedTrustManagerã‚’ä½¿ã†ã¨ã„ã†ã“ã¨ã§ã™ã‹ï¼Ÿ
ChatGPT:

æ€è€ƒæ™‚é–“: 1m 3s
çµè«–ï¼šãã®ã¾ã¾ X509TrustManager ã§ã‚‚OKã§ã™ã€‚
Java 21 ã§ã¯ TrustManagerFactory ã‹ã‚‰è¿”ã£ã¦ãã‚‹å®Ÿä½“ã¯ã»ã¼å¿…ãš X509ExtendedTrustManager ã§ã™ï¼ˆX509TrustManager ã¯â€œã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹â€ã§ã€å®Ÿä½“ãŒãã‚Œã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ï¼‰ã€‚å‰å›ã®æœ€å°å®Ÿè£…ã¯ã€å®Ÿä½“ã«å§”è­²ã—ã¦ PKIX ãƒã‚§ãƒ¼ãƒ³æ¤œè¨¼ã‚’è¡Œã£ã¦ã„ã‚‹ã®ã§ã€ãã®ã¾ã¾å‹•ãã¾ã™ã€‚

ã¨ã¯ã„ãˆã€ŒExtended ã‚’æ˜ç¤ºã—ã¦ãŠããŸã„ã€å ´åˆã®å·®ã—æ›¿ãˆç‰ˆã‚’ç½®ã„ã¦ãŠãã¾ã™ï¼ˆå‹ã ã‘ X509ExtendedTrustManager ã«ã—ã¦ã‚ã‚Šã¾ã™ï¼‰ã€‚Apache ã® TrustStrategy å´ã¯ã‚½ã‚±ãƒƒãƒˆ/SSLEngineã®æ–‡è„ˆã‚’æ¸¡ã—ã¦ãã‚Œãªã„ã®ã§ã€å‘¼ã³å‡ºã™ã®ã¯å¾“æ¥ã©ãŠã‚Š 2 å¼•æ•°ã® checkServerTrusted(chain, authType) ã§ã™ã€‚

ã‚³ãƒ¡ãƒ³ãƒˆä»˜ããƒ»Java 21 å‘ã‘ï¼ˆExtended ã‚’æ˜ç¤ºï¼‰
package com.example.tls;

import org.apache.hc.core5.ssl.TrustStrategy;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509ExtendedTrustManager;
import javax.net.ssl.X509TrustManager;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.KeyStore;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

/**
 * DelegatingTmTrustStrategy (Java 21)
 * - æ—¢å®š/è¿½åŠ  TrustStore ç”±æ¥ã® X509(Extended)TrustManager ã«å§”è­²ã—ã¦ PKIX æ¤œè¨¼ã‚’å®Ÿæ–½
 * - Hostname æ¤œè¨¼ã¯åˆ¥ï¼ˆHttpClient å´ã§ DefaultHostnameVerifier ã‚’å¿…ãšè¨­å®šï¼‰
 */
public final class DelegatingTmTrustStrategy implements TrustStrategy {

    // å®Ÿä½“ã¯ JDK ã® X509ExtendedTrustManagerï¼ˆSunJSSE å®Ÿè£…ï¼‰ã«ãªã‚‹æƒ³å®š
    private final X509ExtendedTrustManager primary;   // ä¾‹: ã‚·ã‚¹ãƒ†ãƒ æ—¢å®š
    private final X509ExtendedTrustManager secondary; // ä¾‹: è¿½åŠ  TrustStoreï¼ˆä»»æ„ï¼‰

    private DelegatingTmTrustStrategy(X509ExtendedTrustManager primary,
                                      X509ExtendedTrustManager secondary) {
        this.primary = primary;
        this.secondary = secondary;
    }

    /** å…¸å‹: ã‚·ã‚¹ãƒ†ãƒ æ—¢å®š â†’ è¿½åŠ  TrustStore ã®é †ã«æ¤œè¨¼ */
    public static DelegatingTmTrustStrategy ofSystemThenExtra(KeyStore extraTrustStore) {
        return new DelegatingTmTrustStrategy(
                tmFrom(null),
                extraTrustStore != null ? tmFrom(extraTrustStore) : null
        );
    }

    /** ç¤¾å†… PKI ã®ã¿ã‚’ä¿¡é ¼ã•ã›ãŸã„å ´åˆï¼ˆå…¬é–‹ CA ã‚’ä½¿ã‚ãªã„ï¼‰ */
    public static DelegatingTmTrustStrategy ofExtraOnly(KeyStore extraTrustStore) {
        if (extraTrustStore == null) throw new IllegalArgumentException("extraTrustStore required");
        return new DelegatingTmTrustStrategy(tmFrom(extraTrustStore), null);
    }

    @Override
    public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        try {
            // â˜… 2å¼•æ•°ã® checkServerTrusted ã‚’å§”è­²ï¼ˆPKIX: ãƒã‚§ãƒ¼ãƒ³æ§‹ç¯‰/ç½²å/æœŸé™/EKUç­‰ã‚’æ¤œè¨¼ï¼‰
            primary.checkServerTrusted(chain, authType);
            return true;
        } catch (CertificateException e) {
            if (secondary != null) {
                secondary.checkServerTrusted(chain, authType);
                return true;
            }
            throw e;
        }
    }

    // ---- helpers ----

    /**
     * KeyStore ã‹ã‚‰ TrustManager ã‚’ç”Ÿæˆã€‚
     * - ks == null â†’ ã‚·ã‚¹ãƒ†ãƒ æ—¢å®šã‚¢ãƒ³ã‚«ãƒ¼
     * - å®Ÿä½“ãŒ X509ExtendedTrustManager ãªã‚‰ãã®ã¾ã¾è¿”ã™
     * - ã¾ã‚Œã« X509TrustManager ã—ã‹æ¥ãªã„å®Ÿè£…å‘ã‘ã«ã€ç°¡æ˜“ãƒ©ãƒƒãƒ‘ã§ Extended ã«è¦‹ã›ã‚‹
     */
    private static X509ExtendedTrustManager tmFrom(KeyStore ks) {
        try {
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(
                    TrustManagerFactory.getDefaultAlgorithm());
            tmf.init(ks); // null ã§ã‚·ã‚¹ãƒ†ãƒ æ—¢å®š

            for (var tm : tmf.getTrustManagers()) {
                if (tm instanceof X509ExtendedTrustManager) {
                    return (X509ExtendedTrustManager) tm;
                }
                if (tm instanceof X509TrustManager) {
                    // Extended ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä½¿ã‚ãªã„ã®ã§ã€2å¼•æ•°ç‰ˆã¸å§”è­²ã™ã‚‹è–„ã„ã‚¢ãƒ€ãƒ—ã‚¿ã§åŒ…ã‚€
                    X509TrustManager base = (X509TrustManager) tm;
                    return new X509ExtendedTrustManager() {
                        @Override public void checkClientTrusted(X509Certificate[] c, String a) throws CertificateException { base.checkClientTrusted(c, a); }
                        @Override public void checkServerTrusted(X509Certificate[] c, String a) throws CertificateException { base.checkServerTrusted(c, a); }
                        @Override public X509Certificate[] getAcceptedIssuers() { return base.getAcceptedIssuers(); }
                        // ä»¥ä¸‹ã¯ Apache å´ã‹ã‚‰å‘¼ã°ã‚Œãªã„ãŒã€å¿µã®ãŸã‚2å¼•æ•°ã¸å§”è­²
                        @Override public void checkClientTrusted(X509Certificate[] c, String a, java.net.Socket s) throws CertificateException { base.checkClientTrusted(c, a); }
                        @Override public void checkServerTrusted(X509Certificate[] c, String a, java.net.Socket s) throws CertificateException { base.checkServerTrusted(c, a); }
                        @Override public void checkClientTrusted(X509Certificate[] c, String a, javax.net.ssl.SSLEngine e) throws CertificateException { base.checkClientTrusted(c, a); }
                        @Override public void checkServerTrusted(X509Certificate[] c, String a, javax.net.ssl.SSLEngine e) throws CertificateException { base.checkServerTrusted(c, a); }
                    };
                }
            }
            throw new IllegalStateException("No X509TrustManager available");
        } catch (Exception e) {
            throw new RuntimeException("Failed to create TrustManager", e);
        }
    }

    /** è¿½åŠ  TrustStore ãƒ­ãƒ¼ãƒ€ï¼ˆJKS/PKCS12 ãªã©ï¼‰ */
    public static KeyStore loadKeyStore(String type, Path path, char[] password) {
        try (InputStream in = Files.newInputStream(path)) {
            KeyStore ks = KeyStore.getInstance(type);
            ks.load(in, password);
            return ks;
        } catch (Exception e) {
            throw new RuntimeException("Failed to load KeyStore: " + path, e);
        }
    }
}
ğŸ” ãƒã‚¤ãƒ³ãƒˆæ•´ç†

ã€ŒcheckServerTrusted ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã€ â†’ ãã®é€šã‚Šã€‚å®Ÿä½“ï¼ˆJDKå®Ÿè£…ï¼‰ã¯ X509ExtendedTrustManager ã§ã€checkServerTrusted(...) ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚ä¸Šã®ã‚³ãƒ¼ãƒ‰ã¯ãã®å®Ÿä½“ã«å§”è­²ã—ã¦ã„ã¾ã™ã€‚

Extended ã‚’ä½¿ã†ã¹ãï¼Ÿ â†’ Apache ã® TrustStrategy ã¯ã‚½ã‚±ãƒƒãƒˆ/SSLEngineæ–‡è„ˆã‚’æ¸¡ã•ãªã„ãŸã‚ã€2å¼•æ•°ãƒ¡ã‚½ãƒƒãƒ‰ã§ååˆ†ã§ã™ï¼ˆHostname æ¤œè¨¼ã¯åˆ¥é€” DefaultHostnameVerifier ãŒæ‹…å½“ï¼‰ã€‚

mTLS ã®åˆ‡æ›¿ â†’ ä»¥å‰ãŠæ¸¡ã—ã—ãŸ TlsHttpClientFactory ã®ã¾ã¾ã§OKï¼ˆloadKeyMaterial(...) ã‚’è¨­å®šã™ã‚‹ã¨åŒæ–¹å‘ã€å¤–ã›ã°å˜æ–¹å‘ï¼‰ã€‚Java 21 ã§ã‚‚åŒã˜ã§ã™ã€‚

å¤±åŠ¹ç¢ºèª â†’ å¿…è¦ãªã‚‰ JVM ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã§æœ‰åŠ¹åŒ–ï¼ˆä¾‹ï¼š-Dcom.sun.net.ssl.checkRevocation=true -Dcom.sun.security.enableCRLDP=true -Dcom.sun.security.ocsp.enable=trueï¼‰ã€‚

ã‚‚ã—ã€ŒJSSE ãŒ ãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯æ–‡è„ˆï¼ˆSocket/SSLEngineï¼‰è¾¼ã¿ã§æ¤œè¨¼ã™ã‚‹ã®ã¨å®Œå…¨ã«åŒã˜æŒ™å‹•ã«ã—ãŸã„ã€ãªã‚‰ã€TrustStrategy ã‚’ä½¿ã‚ãšã«æ¬¡ã®æ–¹æ³•ã‚‚ã‚ã‚Šã¾ã™ï¼š

ã‚·ã‚¹ãƒ†ãƒ ï¼‹è¿½åŠ CAã‚’**ä¸€ã¤ã® TrustStoreï¼ˆçµåˆï¼‰**ã«ã—ã¦ TrustManagerFactory ã‚’ä½œã‚‹

ãã® TrustManager[] ã‚’ SSLContext.init(keyManagers, trustManagers, null) ã«ç›´æ¥æ¸¡ã™

ãã® SSLContext ã‚’ HttpClient ã« setSSLContext(...) ã§æ¸¡ã™

ã“ã®ãƒ«ãƒ¼ãƒˆã ã¨ JSSE ã® X509ExtendedTrustManager ãŒãƒãƒ³ãƒ‰ã‚·ã‚§ã‚¤ã‚¯ã‹ã‚‰ç›´æ¥å‘¼ã°ã‚Œã‚‹ãŸã‚ã€ã‚ˆã‚Šâ€œç´ ã®æŒ™å‹•â€ã«è¿‘ããªã‚Šã¾ã™ï¼ˆå¿…è¦ãªã‚‰ã“ã®çµåˆ TrustStore ç‰ˆã‚‚ç”¨æ„ã—ã¾ã™ï¼‰ã€‚




é¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“é¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“
ChatGPT ã®å›ç­”ã¯å¿…ãšã—ã‚‚æ­£ã—ã„ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚é‡è¦ãªæƒ…å ±ã¯ç¢ºèªã™ã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚
