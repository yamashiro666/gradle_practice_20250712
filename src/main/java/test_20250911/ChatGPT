コンテンツへとスキップする
チャット履歴

あなた:
javaのtruststrategyを使ってサーバ証明書の検証を行う実装をかけますか。
証明書チェーンを意識した実装をしてください。
ChatGPT:

思考時間: 2m 3s
はい、できます。Apache HttpClient の TrustStrategy を使いつつ、証明書チェーンを正しく組み立てて PKIX で検証する実装例です。
（注: Hostname 検証は TrustStrategy では行えないため、後述のとおり DefaultHostnameVerifier を必ず併用してください。）

1) チェーン検証する TrustStrategy 実装
package com.example.tls;

import org.apache.hc.core5.ssl.TrustStrategy; // HttpClient 5 系を想定（4.5 系なら org.apache.http.ssl.TrustStrategy）

import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;
import java.security.KeyStore;
import java.security.cert.*;
import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

/**
 * サーバから提示された証明書チェーンを PKIX で検証する TrustStrategy。
 * - システム既定の信頼ストア + 任意のカスタム TrustStore を信頼アンカーとして使用
 * - PKIX CertPathBuilder でルートまでの経路を構築して検証
 * - 末端証明書の KeyUsage / EKU(serverAuth) / 有効期限 を追加チェック
 * - Hostname 検証は別途 DefaultHostnameVerifier で行ってください
 */
public final class ChainValidatingTrustStrategy implements TrustStrategy {

    private final Set<TrustAnchor> trustAnchors;
    private final Collection<X509Certificate> extraIntermediates;
    private final boolean enableRevocation; // OCSP/CRL を使った失効確認（必要に応じて true）

    private static final String EKU_SERVER_AUTH_OID = "1.3.6.1.5.5.7.3.1";

    public static Builder builder() {
        return new Builder();
    }

    private ChainValidatingTrustStrategy(Set<TrustAnchor> trustAnchors,
                                         Collection<X509Certificate> extraIntermediates,
                                         boolean enableRevocation) {
        this.trustAnchors = Objects.requireNonNull(trustAnchors, "trustAnchors");
        this.extraIntermediates = Objects.requireNonNull(extraIntermediates, "extraIntermediates");
        this.enableRevocation = enableRevocation;
    }

    @Override
    public boolean isTrusted(final X509Certificate[] chain, final String authType) throws CertificateException {
        if (chain == null || chain.length == 0) {
            throw new CertificateException("Empty server certificate chain.");
        }

        // 0 がエンドエンティティ（サーバ）想定
        final X509Certificate endEntity = chain[0];

        try {
            // presented chain + extra intermediates を CertStore として投入
            List<X509Certificate> presented = Arrays.asList(chain);
            Collection<X509Certificate> allIntermediates = new ArrayList<>(presented);
            allIntermediates.addAll(extraIntermediates);

            CertStore certStore = CertStore.getInstance("Collection",
                    new CollectionCertStoreParameters(allIntermediates));

            // 目標（ターゲット）はサーバ証明書
            X509CertSelector selector = new X509CertSelector();
            selector.setCertificate(endEntity);

            PKIXBuilderParameters params = new PKIXBuilderParameters(trustAnchors, selector);
            params.addCertStore(certStore);

            // 失効確認
            params.setRevocationEnabled(enableRevocation);
            if (enableRevocation) {
                // 高度にやるなら PKIXRevocationChecker のオプションをチューニング
                CertPathValidator cpv = CertPathValidator.getInstance("PKIX");
                PKIXRevocationChecker revChecker = (PKIXRevocationChecker) cpv.getRevocationChecker();
                // 例: CRL 優先、フォールバックなし など（必要に応じて調整）
                revChecker.setOptions(EnumSet.of(
                        PKIXRevocationChecker.Option.PREFER_CRLS,
                        PKIXRevocationChecker.Option.NO_FALLBACK
                ));
                params.addCertPathChecker(revChecker);
            }

            // 経路構築（順不同のチェーンでも OK）
            CertPathBuilder builder = CertPathBuilder.getInstance("PKIX");
            PKIXCertPathBuilderResult result = (PKIXCertPathBuilderResult) builder.build(params);

            // PKIX の構築時点で署名/発行者/期限などは検証済みだが、
            // Web サーバ用途としての追加チェックをしておく
            checkEndEntityForTlsServer(endEntity);

            // ここまで来れば信頼可
            return true;

        } catch (CertPathBuilderException e) {
            throw new CertificateException("Could not build a valid certification path to a trusted root: " + e.getMessage(), e);
        } catch (GeneralSecurityException e) {
            throw new CertificateException("Certificate path validation failed: " + e.getMessage(), e);
        }
    }

    /**
     * Web サーバ証明書としての最低限チェック:
     * - 現在時刻が有効期間内
     * - KeyUsage: digitalSignature / keyEncipherment のどちらか（RSA）や keyAgreement（ECDHE 等）を想定
     * - EKU に serverAuth を含む（省略＝制限なしの場合は許容）
     */
    private static void checkEndEntityForTlsServer(X509Certificate cert) throws CertificateException {
        // 期限
        Instant now = Instant.now();
        try {
            cert.checkValidity(Date.from(now));
        } catch (CertificateExpiredException | CertificateNotYetValidException ex) {
            throw new CertificateException("End-entity certificate is not valid now: " + ex.getMessage(), ex);
        }

        // EKU（存在する場合は serverAuth を要求）
        try {
            List<String> eku = cert.getExtendedKeyUsage(); // may be null
            if (eku != null && !eku.contains(EKU_SERVER_AUTH_OID)) {
                throw new CertificateException("End-entity certificate EKU does not include serverAuth.");
            }
        } catch (CertificateParsingException e) {
            throw new CertificateException("Failed to parse Extended Key Usage.", e);
        }

        // KeyUsage（存在する場合）
        boolean[] ku = cert.getKeyUsage(); // may be null
        if (ku != null) {
            // digitalSignature(0) or keyEncipherment(2) or keyAgreement(4) のいずれかを許容
            boolean ok = (ku.length > 0 && ku[0]) || (ku.length > 2 && ku[2]) || (ku.length > 4 && ku[4]);
            if (!ok) {
                throw new CertificateException("End-entity certificate KeyUsage is not suitable for TLS server.");
            }
        }
    }

    // ===== Builder / ユーティリティ =====

    public static final class Builder {
        private final List<KeyStore> customTrustStores = new ArrayList<>();
        private final List<X509Certificate> extraIntermediates = new ArrayList<>();
        private boolean enableRevocation = false;
        private boolean includeSystemDefaultAnchors = true;

        /** 既定（JRE/OS）の信頼アンカーを含めるか（既定: true） */
        public Builder includeSystemDefaultAnchors(boolean include) {
            this.includeSystemDefaultAnchors = include;
            return this;
        }

        /** 追加の TrustStore（JKS/PKCS12 など）を信頼アンカーとして使用 */
        public Builder addTrustStore(KeyStore ks) {
            this.customTrustStores.add(Objects.requireNonNull(ks));
            return this;
        }

        /** AIA 取得ができない環境などで、中間 CA を手動投入したい場合に使用 */
        public Builder addIntermediate(X509Certificate intermediate) {
            this.extraIntermediates.add(Objects.requireNonNull(intermediate));
            return this;
        }

        /** OCSP/CRL による失効確認を有効化（環境設定が必要） */
        public Builder enableRevocation(boolean enable) {
            this.enableRevocation = enable;
            return this;
        }

        public ChainValidatingTrustStrategy build() {
            Set<TrustAnchor> anchors = new HashSet<>();
            if (includeSystemDefaultAnchors) {
                anchors.addAll(loadSystemDefaultAnchors());
            }
            for (KeyStore ks : customTrustStores) {
                anchors.addAll(loadAnchorsFromKeyStore(ks));
            }
            if (anchors.isEmpty()) {
                throw new IllegalStateException("No trust anchors configured.");
            }
            return new ChainValidatingTrustStrategy(anchors, extraIntermediates, enableRevocation);
        }
    }

    /** システム既定（JRE/OS）の信頼アンカーを抽出 */
    private static Set<TrustAnchor> loadSystemDefaultAnchors() {
        try {
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
            tmf.init((KeyStore) null); // システム既定
            Set<TrustAnchor> result = new HashSet<>();
            for (TrustManager tm : tmf.getTrustManagers()) {
                if (tm instanceof X509TrustManager) {
                    for (X509Certificate ca : ((X509TrustManager) tm).getAcceptedIssuers()) {
                        result.add(new TrustAnchor(ca, null));
                    }
                }
            }
            return result;
        } catch (GeneralSecurityException e) {
            throw new RuntimeException("Failed to load system default trust anchors: " + e.getMessage(), e);
        }
    }

    /** 任意の KeyStore から信頼アンカーを抽出（"trustedCertEntry" を対象） */
    private static Set<TrustAnchor> loadAnchorsFromKeyStore(KeyStore ks) {
        try {
            Set<TrustAnchor> result = new HashSet<>();
            for (Enumeration<String> e = ks.aliases(); e.hasMoreElements(); ) {
                String alias = e.nextElement();
                if (ks.isCertificateEntry(alias)) {
                    Certificate c = ks.getCertificate(alias);
                    if (c instanceof X509Certificate) {
                        result.add(new TrustAnchor((X509Certificate) c, null));
                    }
                }
            }
            return result;
        } catch (GeneralSecurityException e) {
            throw new RuntimeException("Failed to read anchors from KeyStore: " + e.getMessage(), e);
        }
    }

    /** 参考：KeyStore ローダ（JKS/PKCS12） */
    public static KeyStore loadKeyStore(String type, java.nio.file.Path path, char[] password) {
        try (java.io.InputStream in = java.nio.file.Files.newInputStream(path)) {
            KeyStore ks = KeyStore.getInstance(type); // "JKS" or "PKCS12"
            ks.load(in, password);
            return ks;
        } catch (Exception e) {
            throw new RuntimeException("Failed to load KeyStore: " + e.getMessage(), e);
        }
    }

    /** 参考：人間向けダンプ（デバッグ用） */
    public static String describeChain(X509Certificate[] chain) {
        if (chain == null) return "<null>";
        return Arrays.stream(chain)
                .map(c -> String.format("CN=%s, Issuer=%s, Serial=%s",
                        getCN(c.getSubjectX500Principal().getName()),
                        getCN(c.getIssuerX500Principal().getName()),
                        c.getSerialNumber().toString(16)))
                .collect(Collectors.joining(" -> "));
    }

    private static String getCN(String dn) {
        for (String part : dn.split(",")) {
            String p = part.trim();
            if (p.startsWith("CN=")) return p.substring(3);
        }
        return dn;
    }
}
2) HttpClient 5 への組み込み例（Hostname 検証も必須）
import com.example.tls.ChainValidatingTrustStrategy;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClients;
import org.apache.hc.client5.http.ssl.DefaultHostnameVerifier;
import org.apache.hc.core5.ssl.SSLContextBuilder;

import javax.net.ssl.SSLContext;
import java.nio.file.Paths;
import java.security.KeyStore;

public class HttpClientFactory {

    public static CloseableHttpClient create() throws Exception {
        // 例: 追加の社内 CA を truststore.jks から読み込む
        KeyStore corpTrust = ChainValidatingTrustStrategy.loadKeyStore(
                "JKS",
                Paths.get("config/truststore.jks"),
                "changeit".toCharArray()
        );

        ChainValidatingTrustStrategy ts = ChainValidatingTrustStrategy.builder()
                .includeSystemDefaultAnchors(true)     // 既定のルート CA も許可
                .addTrustStore(corpTrust)              // 追加の社内 CA を許可
                .enableRevocation(false)               // 必要に応じて true（環境構築が必要）
                .build();

        SSLContext sslContext = SSLContextBuilder.create()
                // truststore は null でも OK。TrustStrategy が最終判断を行う
                .loadTrustMaterial(null, ts)
                .build();

        return HttpClients.custom()
                .setSSLContext(sslContext)
                .setSSLHostnameVerifier(new DefaultHostnameVerifier()) // ★ Hostname 検証を必ず有効に
                .build();
    }
}
📝 ポイント

TrustStrategy は「このチェーンを信頼するか」の判断のみ。ホスト名検証（SAN/CN の一致）は別なので、DefaultHostnameVerifier を必ず設定してください。

失効確認（OCSP/CRL）を行う場合は enableRevocation(true) に加えて、実行環境で OCSP/CRL が参照できるようネットワーク/プロキシ/システムプロパティを整備してください（例：-Dcom.sun.security.enableCRLDP=true -Dcom.sun.net.ssl.checkRevocation=true -Dcom.sun.security.ocsp.enable=true 等）。

サーバが 中間 CA を省略してくることがあります。AIA からの自動取得を期待できない環境では、addIntermediate(...) に中間証明書を投入してください。

3) Spring (RestTemplate / WebClient) で使う場合のヒント
RestTemplate なら HttpComponentsClientHttpRequestFactory に上記 CloseableHttpClient を渡す。

Spring WebClient(Netty) を使う場合は Netty の SslContextBuilder で同様の検証ロジックを自作 TrustManager に移植します（Netty は Apache の TrustStrategy を直接は使えません）。

必要なら、ピン留め（証明書/公開鍵ピンニング）や特定の中間 CA のみ許容といったポリシーも、このクラスに簡単に拡張できます。
この方針で大丈夫そうなら、あなたの環境（Java / HttpClient のメジャーバージョン、Spring の構成）に合わせて最適化した版をすぐ用意します。

あなた:
ちなみにもっと短くできったりしますか？
ChatGPT:

思考時間: 1m 7s
はい。最短で“安全なチェーン検証”に寄せるなら、TrustStrategyの中で JSSE の標準 X509TrustManager に委譲するのがコンパクトです。
（＝PKIX チェーン構築・検証は TrustManagerFactory が実施。Hostname 検証は別途 DefaultHostnameVerifier を必ず併用。）

最小実装（約60行）
package com.example.tls;

import org.apache.hc.core5.ssl.TrustStrategy; // HttpClient 5（4.5系はorg.apache.http.ssl.TrustStrategy）

import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.KeyStore;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

/**
 * システム既定 + 任意のTrustStore の X509TrustManager に委譲して
 * サーバ証明書チェーンを PKIX で検証する最小TrustStrategy。
 */
public final class DelegatingTmTrustStrategy implements TrustStrategy {

    private final X509TrustManager sysTm;   // システム既定
    private final X509TrustManager extraTm; // 追加TrustStore（任意、null可）

    private DelegatingTmTrustStrategy(X509TrustManager sysTm, X509TrustManager extraTm) {
        this.sysTm = sysTm;
        this.extraTm = extraTm;
    }

    /** 追加のTrustStore（JKS/PKCS12）を使いたい時だけ渡す。不要ならnull */
    public static DelegatingTmTrustStrategy of(KeyStore extraTrustStore) {
        return new DelegatingTmTrustStrategy(
                tmFrom(null),                                // system default anchors
                extraTrustStore != null ? tmFrom(extraTrustStore) : null
        );
    }

    @Override
    public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        try {
            sysTm.checkServerTrusted(chain, authType); // 既定の信頼ストアで検証（チェーン構築含む）
            return true;
        } catch (CertificateException e) {
            if (extraTm != null) {
                // 社内CAなど追加TrustStoreでもう一度検証
                extraTm.checkServerTrusted(chain, authType);
                return true;
            }
            throw e;
        }
    }

    // ---- helpers ----
    private static X509TrustManager tmFrom(KeyStore ks) {
        try {
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(
                    TrustManagerFactory.getDefaultAlgorithm());
            tmf.init(ks); // null=システム既定
            return (X509TrustManager) java.util.Arrays.stream(tmf.getTrustManagers())
                    .filter(tm -> tm instanceof X509TrustManager)
                    .findFirst().orElseThrow(() -> new IllegalStateException("No X509TrustManager"));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /** 追加 TrustStore 用ローダ（例: "JKS" / "PKCS12"） */
    public static KeyStore loadKeyStore(String type, Path path, char[] password) {
        try (InputStream in = Files.newInputStream(path)) {
            KeyStore ks = KeyStore.getInstance(type);
            ks.load(in, password);
            return ks;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
HttpClient 5 への組み込み（最小）
import com.example.tls.DelegatingTmTrustStrategy;
import org.apache.hc.client5.http.impl.classic.HttpClients;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.ssl.DefaultHostnameVerifier;
import org.apache.hc.core5.ssl.SSLContextBuilder;

import javax.net.ssl.SSLContext;
import java.nio.file.Paths;
import java.security.KeyStore;

public class ClientFactory {
    public static CloseableHttpClient create() throws Exception {
        // 追加の社内CAがある場合だけ読み込む（無ければ extraKs = null）
        KeyStore extraKs = DelegatingTmTrustStrategy.loadKeyStore(
                "JKS", Paths.get("config/truststore.jks"), "changeit".toCharArray());

        SSLContext ssl = SSLContextBuilder.create()
                .loadTrustMaterial(null, DelegatingTmTrustStrategy.of(extraKs))
                .build();

        return HttpClients.custom()
                .setSSLContext(ssl)
                .setSSLHostnameVerifier(new DefaultHostnameVerifier()) // ★必須：ホスト名検証
                .build();
    }
}
補足（短さ優先の代わりに省いたもの）
EKU(KeyUsage)や失効確認(OCSP/CRL)の追加チェックは割愛。必要なら前回案のように拡張してください。

AIA からの中間CA取得に頼らず確実に通したい場合は、中間CAを truststore に入れてください。

この形なら、チェーン検証は TrustManager に丸投げでき、コード量を最小化しつつ「システム既定＋追加TrustStore」にも対応できます。

あなた:
できれば、何をやっているかコード上にコメントを書いて欲しいのですが可能ですか。
ChatGPT:

思考時間: 16s
もちろんです。最小構成＋要点に絞った日本語コメント入りで用意しました。
（HttpClient 5 系想定。4.5 系なら org.apache.http.ssl.TrustStrategy に置き換えてください）

1) TrustStrategy 実装（チェーン検証は標準 TrustManager に委譲）
package com.example.tls;

import org.apache.hc.core5.ssl.TrustStrategy; // HttpClient 5 系
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.KeyStore;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

/**
 * DelegatingTmTrustStrategy
 *
 * 目的:
 * - サーバが提示した証明書チェーンの検証を、標準の PKIX 実装(X509TrustManager)に委譲して行う。
 * - 「システム既定の信頼ストア（OS/JRE）」に加え、必要に応じて「社内CAなどの追加 TrustStore」でも検証する。
 *
 * ポイント:
 * - 証明書チェーンの構築/署名検証/有効期限などは TrustManagerFactory に任せるので実装が短い。
 * - Hostname 検証は TrustStrategy の役割外。HttpClient 側で DefaultHostnameVerifier を必ず有効にすること。
 */
public final class DelegatingTmTrustStrategy implements TrustStrategy {

    // システム既定の信頼アンカーから作った X509TrustManager
    private final X509TrustManager systemTm;

    // 追加の TrustStore（任意）。社内CAなどを入れておくと、ここでもう一度検証できる
    private final X509TrustManager extraTm;

    private DelegatingTmTrustStrategy(X509TrustManager systemTm, X509TrustManager extraTm) {
        this.systemTm = systemTm;
        this.extraTm = extraTm;
    }

    /**
     * ファクトリ:
     *   - extraTrustStore が null の場合は「システム既定のみ」で検証
     *   - 渡された場合は「システム既定 → ダメなら追加 TrustStore」の順で検証
     */
    public static DelegatingTmTrustStrategy of(KeyStore extraTrustStore) {
        return new DelegatingTmTrustStrategy(
                tmFrom(null),                                // null を渡すとシステム既定の信頼ストアを使用
                (extraTrustStore != null) ? tmFrom(extraTrustStore) : null
        );
    }

    /**
     * TrustStrategy の本体。
     * HttpClient が TLS ハンドシェイクで受け取ったサーバ証明書チェーンと authType を渡してくる。
     *
     * ここでは:
     *  1) まずシステム既定の TrustManager で「サーバ用のチェーン」として検証
     *  2) それでダメなら、追加 TrustStore（存在する場合）で再検証
     *  3) 両方ダメなら信頼不可（例外投げる）
     *
     * 戻り値 true の意味:
     *  - 「信頼できる」＝「ルートまでの認証経路が正しく構築でき、署名や期限など PKIX 検証に合格した」
     */
    @Override
    public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        try {
            // システム既定のアンカーに対して PKIX 検証（中間が一部足りない場合も、AIA 取得などで補完されることがある）
            systemTm.checkServerTrusted(chain, authType);
            return true;
        } catch (CertificateException first) {
            // システム既定で失敗。追加 TrustStore があれば再トライ
            if (extraTm != null) {
                extraTm.checkServerTrusted(chain, authType); // ここで通れば信頼OK
                return true;
            }
            // どちらでも通らない場合は検証失敗として投げ直す
            throw first;
        }
    }

    // === ヘルパ ===

    /**
     * 任意の KeyStore から X509TrustManager を作る。
     * - ks == null の場合: システム既定の信頼アンカー集合を使う
     * - ks != null の場合: 渡された TrustStore（JKS/PKCS12 等）に入っている「信頼できる証明書」をアンカーにする
     */
    private static X509TrustManager tmFrom(KeyStore ks) {
        try {
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(
                    TrustManagerFactory.getDefaultAlgorithm());
            tmf.init(ks); // null で初期化するとシステム既定を使用
            return (X509TrustManager) java.util.Arrays.stream(tmf.getTrustManagers())
                    .filter(tm -> tm instanceof X509TrustManager)
                    .findFirst()
                    .orElseThrow(() -> new IllegalStateException("No X509TrustManager available"));
        } catch (Exception e) {
            throw new RuntimeException("Failed to create X509TrustManager", e);
        }
    }

    /**
     * 追加 TrustStore ローダ（JKS/PKCS12 など）。
     * 例:
     *   KeyStore ks = loadKeyStore("JKS", Paths.get("config/truststore.jks"), "changeit".toCharArray());
     */
    public static KeyStore loadKeyStore(String type, Path path, char[] password) {
        try (InputStream in = Files.newInputStream(path)) {
            KeyStore ks = KeyStore.getInstance(type); // "JKS" or "PKCS12"
            ks.load(in, password);
            return ks;
        } catch (Exception e) {
            throw new RuntimeException("Failed to load KeyStore: " + path, e);
        }
    }
}
2) HttpClient5 への組み込み例（Hostname 検証の有効化を含む）
import com.example.tls.DelegatingTmTrustStrategy;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClients;
import org.apache.hc.client5.http.ssl.DefaultHostnameVerifier; // ★ ホスト名検証用
import org.apache.hc.core5.ssl.SSLContextBuilder;

import javax.net.ssl.SSLContext;
import java.nio.file.Paths;
import java.security.KeyStore;

public class ClientFactory {

    public static CloseableHttpClient create() throws Exception {
        // 1) 追加の社内 CA を truststore から読み込み（不要なら null を渡す）
        //    - truststore には「信頼したい中間/ルート CA（trustedCertEntry）」を入れておく
        KeyStore extraKs = DelegatingTmTrustStrategy.loadKeyStore(
                "JKS", Paths.get("config/truststore.jks"), "changeit".toCharArray()
        );

        // 2) TrustStrategy を SSLContext に組み込む
        SSLContext sslContext = SSLContextBuilder.create()
                // KeyStore 引数は null（＝ここでは固定 truststore を持たない）。
                // 最終判断は TrustStrategy 側で実施（＝内部の TrustManager に委譲）
                .loadTrustMaterial(null, DelegatingTmTrustStrategy.of(extraKs))
                .build();

        // 3) HttpClient を構築
        return HttpClients.custom()
                .setSSLContext(sslContext)
                // ★ 重要：Hostname 検証は TrustStrategy の範囲外。ここで必ず有効化する。
                //    - サーバ証明書の SAN/CN と接続先ホスト名の一致を検証
                .setSSLHostnameVerifier(new DefaultHostnameVerifier())
                .build();
    }
}
運用メモ（よくあるポイント）
中間 CA がサーバから送られてこない環境では、truststore.jks に中間 CA を入れておくと安定します（AIA 取得に頼らない）。

**失効確認（OCSP/CRL）**までやりたい場合は、TrustStrategy ではなく JVM 全体の revocation 設定を有効にするのが簡単です：
例）-Dcom.sun.net.ssl.checkRevocation=true -Dcom.sun.security.enableCRLDP=true -Dcom.sun.security.ocsp.enable=true
（プロキシ設定・OCSP/CRL への到達性など環境整備が別途必要）

HttpClient 4.5 系を使う場合は、import org.apache.http.ssl.TrustStrategy; に変えるだけで概ね同じ発想で動きます。

必要なら、この最小版に EKU(serverAuth) / KeyUsage の追加チェックや、特定 CA のみ許容（ピンニング相当）などもコメント付きで拡張します。

あなた:
この最小コードは、証明書チェーン以外の検証も行えていますか？
また、単方向・双方向の切り替えができるようにしてほしいのですが、可能でしょうか。
ChatGPT:

思考時間: 59s
いい質問です。まず結論から：

1) この最小コードが行っている「チェーン以外の検証」
checkServerTrusted(...) を使っているため JSSE の PKIX 検証が有効です。つまり——

✅ 署名連鎖（ルートまでの経路構築と検証）

✅ 有効期限チェック（期限切れ／未有効）

✅ BasicConstraints / CA かどうか（中間は CA 必須）

✅ KeyUsage / ExtendedKeyUsage
EKU が存在する場合は serverAuth を含む必要があります（無指定＝制限なしは許容）。
KeyUsage はスイートに応じて digitalSignature / keyEncipherment / keyAgreement の適合が求められます。

✅ アルゴリズム制限（jdk.certpath.disabledAlgorithms などの JDK 設定に従う）

⛔ 含まれないもの

ホスト名検証（SAN/CN と接続先ホスト名の一致）→ DefaultHostnameVerifier で必ず実施

失効確認（OCSP/CRL） → 既定は無効。必要なら JVM のプロパティで有効化
例：-Dcom.sun.net.ssl.checkRevocation=true -Dcom.sun.security.enableCRLDP=true -Dcom.sun.security.ocsp.enable=true

2) 単方向 / 双方向（mTLS）の切り替え対応版
単方向 TLS（サーバ証明書のみ検証）…従来どおり TrustStrategy + HostnameVerifier

双方向 TLS (mTLS) …上に クライアント証明書（KeyManager） を追加して切り替え

下は 短さ優先＋日本語コメント入りの実装です。

A) TrustStrategy（順番とアンカー範囲も切替可能）
package com.example.tls;

import org.apache.hc.core5.ssl.TrustStrategy;

import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.KeyStore;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

/**
 * 目的:
 *  - サーバが提示した証明書チェーンの PKIX 検証を標準 X509TrustManager に委譲
 *  - 「システム既定アンカー」と「追加 TrustStore」を順番付きで使い分け可能
 *
 * 注意:
 *  - Hostname 検証は別（HttpClient 側で DefaultHostnameVerifier を設定）
 *  - 失効確認は JVM 全体の設定で有効化（TrustStrategy では行わない）
 */
public final class DelegatingTmTrustStrategy implements TrustStrategy {

    // 1st トライ用 TrustManager（例: システム既定 or 追加 TrustStore）
    private final X509TrustManager primary;

    // フォールバック用（任意、null 可）
    private final X509TrustManager secondary;

    private DelegatingTmTrustStrategy(X509TrustManager primary, X509TrustManager secondary) {
        this.primary = primary;
        this.secondary = secondary;
    }

    /** システム既定 → 追加TrustStore の順（一般的な構成） */
    public static DelegatingTmTrustStrategy ofSystemThenExtra(KeyStore extraTrustStore) {
        return new DelegatingTmTrustStrategy(tmFrom(null),
                extraTrustStore != null ? tmFrom(extraTrustStore) : null);
    }

    /** 追加TrustStore のみ（社内 PKI だけを信頼したい場合） */
    public static DelegatingTmTrustStrategy ofExtraOnly(KeyStore extraTrustStore) {
        if (extraTrustStore == null) throw new IllegalArgumentException("extraTrustStore required");
        return new DelegatingTmTrustStrategy(tmFrom(extraTrustStore), null);
    }

    /** 追加TrustStore → システム既定 の順（社内 CA を優先したい場合） */
    public static DelegatingTmTrustStrategy ofExtraThenSystem(KeyStore extraTrustStore) {
        if (extraTrustStore == null) throw new IllegalArgumentException("extraTrustStore required");
        return new DelegatingTmTrustStrategy(tmFrom(extraTrustStore), tmFrom(null));
    }

    @Override
    public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        try {
            // まず primary（例: システム既定）で検証
            primary.checkServerTrusted(chain, authType);
            return true;
        } catch (CertificateException e) {
            // ダメなら secondary（例: 追加 TrustStore）で再トライ
            if (secondary != null) {
                secondary.checkServerTrusted(chain, authType);
                return true;
            }
            throw e;
        }
    }

    // --- ヘルパ ---

    /** ks == null ならシステム既定アンカーから TM を作成、そうでなければ ks をアンカーに TM を作成 */
    private static X509TrustManager tmFrom(KeyStore ks) {
        try {
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(
                    TrustManagerFactory.getDefaultAlgorithm());
            tmf.init(ks); // null → システム既定
            return (X509TrustManager) java.util.Arrays.stream(tmf.getTrustManagers())
                    .filter(tm -> tm instanceof X509TrustManager)
                    .findFirst()
                    .orElseThrow(() -> new IllegalStateException("No X509TrustManager available"));
        } catch (Exception e) {
            throw new RuntimeException("Failed to create X509TrustManager", e);
        }
    }

    /** TrustStore ローダ（JKS/PKCS12 など） */
    public static KeyStore loadKeyStore(String type, Path path, char[] password) {
        try (InputStream in = Files.newInputStream(path)) {
            KeyStore ks = KeyStore.getInstance(type);
            ks.load(in, password);
            return ks;
        } catch (Exception e) {
            throw new RuntimeException("Failed to load KeyStore: " + path, e);
        }
    }
}
B) HttpClient 工場（単方向／双方向を切替）
package com.example.tls;

import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClients;
import org.apache.hc.client5.http.ssl.DefaultHostnameVerifier; // ★ホスト名検証
import org.apache.hc.core5.ssl.SSLContextBuilder;
import org.apache.hc.core5.ssl.PrivateKeyStrategy;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLContext;
import java.net.Socket;
import java.nio.file.Paths;
import java.security.KeyStore;
import java.util.Map;

/**
 * 単方向（サーバ認証のみ）/ 双方向（mTLS）の切り替え可能な HttpClient ファクトリ。
 */
public final class TlsHttpClientFactory {

    public enum Mode { ONE_WAY, MUTUAL } // 単方向 / 双方向

    /**
     * @param mode                 ONE_WAY or MUTUAL
     * @param trustStrategy        サーバ検証用の TrustStrategy（上記 DelegatingTmTrustStrategy）
     * @param clientKeyStore       MUTUAL 時のみ必須（PKCS12/JKS にクライアント証明書＋秘密鍵）
     * @param clientKeyPassword    上記の鍵パスワード（鍵とストアが同じなら同一パス可）
     * @param clientKeyAlias       複数エイリアスがある場合の選択（null ならデフォルト選択）
     * @param hostnameVerifier     null の場合は DefaultHostnameVerifier を使用
     */
    public static CloseableHttpClient create(
            Mode mode,
            DelegatingTmTrustStrategy trustStrategy,
            KeyStore clientKeyStore,
            char[] clientKeyPassword,
            String clientKeyAlias,
            HostnameVerifier hostnameVerifier
    ) throws Exception {

        SSLContextBuilder b = SSLContextBuilder.create()
                // TrustStrategy に最終判断を委譲（JVM 既定 + 追加 TrustStore など）
                .loadTrustMaterial(null, trustStrategy);

        if (mode == Mode.MUTUAL) {
            if (clientKeyStore == null || clientKeyPassword == null) {
                throw new IllegalArgumentException("clientKeyStore/clientKeyPassword required for MUTUAL");
            }
            if (clientKeyAlias == null) {
                // 単一鍵 or 既定鍵ならそのまま
                b.loadKeyMaterial(clientKeyStore, clientKeyPassword);
            } else {
                // 指定エイリアスを選ぶ場合（複数鍵が入っている PKCS12/JKS を想定）
                PrivateKeyStrategy pickAlias = (aliases, socket) -> {
                    // 引数 aliases: Map<alias, PrivateKeyDetails>
                    return aliases.containsKey(clientKeyAlias) ? clientKeyAlias : null;
                };
                b.loadKeyMaterial(clientKeyStore, clientKeyPassword, pickAlias);
            }
        }

        SSLContext ssl = b.build();

        return HttpClients.custom()
                .setSSLContext(ssl)
                .setSSLHostnameVerifier(hostnameVerifier != null ? hostnameVerifier : new DefaultHostnameVerifier())
                .build();
    }

    // --- 使用例 ---

    public static CloseableHttpClient exampleOneWay() throws Exception {
        // 追加の社内 CA を読む（不要なら null でも可）
        KeyStore extra = DelegatingTmTrustStrategy.loadKeyStore(
                "JKS", Paths.get("config/truststore.jks"), "changeit".toCharArray());

        DelegatingTmTrustStrategy ts = DelegatingTmTrustStrategy.ofSystemThenExtra(extra);

        return create(Mode.ONE_WAY, ts, null, null, null, null);
    }

    public static CloseableHttpClient exampleMutual() throws Exception {
        // 追加の社内 CA（必要時のみ）
        KeyStore extra = DelegatingTmTrustStrategy.loadKeyStore(
                "JKS", Paths.get("config/truststore.jks"), "changeit".toCharArray());
        DelegatingTmTrustStrategy ts = DelegatingTmTrustStrategy.ofSystemThenExtra(extra);

        // クライアント証明書（PKCS12 推奨）
        KeyStore clientKs = DelegatingTmTrustStrategy.loadKeyStore(
                "PKCS12", Paths.get("secrets/client.p12"), "p12pass".toCharArray());

        return create(Mode.MUTUAL, ts, clientKs, "p12pass".toCharArray(), null, null);
    }
}
使い分けの指針
公開サイト向け：ofSystemThenExtra(...)（システム既定 → 追加 CA）

社内 PKI のみ信頼：ofExtraOnly(...)（公開 CA を無効化）

社内 CA を優先：ofExtraThenSystem(...)

mTLS を使う：サーバ側で「クライアント証明書必須 or 要求」を有効化し、クライアントに loadKeyMaterial(...) を設定

✅ すべてのモードで Hostname 検証は忘れずに（DefaultHostnameVerifier）。
🔎 失効確認が必要なら JVM プロパティで有効化してください（ネットワーク到達性・プロキシ設定も要確認）。

必要なら、**EKU(serverAuth) や特定 CA のみ許容（ピンニング相当）**といった追加ルールもこの構成に薄く足せます。あなたの Spring/Gradle 環境に合わせたテンプレ化（プロパティ駆動の切替）もすぐ出します。

あなた:
Javaは21を使っているのですが、checkServerTrustedはインターフェイスのように見えます。X509ExtendedTrustManagerを使うということですか？
ChatGPT:

思考時間: 1m 3s
結論：そのまま X509TrustManager でもOKです。
Java 21 では TrustManagerFactory から返ってくる実体はほぼ必ず X509ExtendedTrustManager です（X509TrustManager は“インターフェース”で、実体がそれを実装しています）。前回の最小実装は、実体に委譲して PKIX チェーン検証を行っているので、そのまま動きます。

とはいえ「Extended を明示しておきたい」場合の差し替え版を置いておきます（型だけ X509ExtendedTrustManager にしてあります）。Apache の TrustStrategy 側はソケット/SSLEngineの文脈を渡してくれないので、呼び出すのは従来どおり 2 引数の checkServerTrusted(chain, authType) です。

コメント付き・Java 21 向け（Extended を明示）
package com.example.tls;

import org.apache.hc.core5.ssl.TrustStrategy;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509ExtendedTrustManager;
import javax.net.ssl.X509TrustManager;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.KeyStore;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

/**
 * DelegatingTmTrustStrategy (Java 21)
 * - 既定/追加 TrustStore 由来の X509(Extended)TrustManager に委譲して PKIX 検証を実施
 * - Hostname 検証は別（HttpClient 側で DefaultHostnameVerifier を必ず設定）
 */
public final class DelegatingTmTrustStrategy implements TrustStrategy {

    // 実体は JDK の X509ExtendedTrustManager（SunJSSE 実装）になる想定
    private final X509ExtendedTrustManager primary;   // 例: システム既定
    private final X509ExtendedTrustManager secondary; // 例: 追加 TrustStore（任意）

    private DelegatingTmTrustStrategy(X509ExtendedTrustManager primary,
                                      X509ExtendedTrustManager secondary) {
        this.primary = primary;
        this.secondary = secondary;
    }

    /** 典型: システム既定 → 追加 TrustStore の順に検証 */
    public static DelegatingTmTrustStrategy ofSystemThenExtra(KeyStore extraTrustStore) {
        return new DelegatingTmTrustStrategy(
                tmFrom(null),
                extraTrustStore != null ? tmFrom(extraTrustStore) : null
        );
    }

    /** 社内 PKI のみを信頼させたい場合（公開 CA を使わない） */
    public static DelegatingTmTrustStrategy ofExtraOnly(KeyStore extraTrustStore) {
        if (extraTrustStore == null) throw new IllegalArgumentException("extraTrustStore required");
        return new DelegatingTmTrustStrategy(tmFrom(extraTrustStore), null);
    }

    @Override
    public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        try {
            // ★ 2引数の checkServerTrusted を委譲（PKIX: チェーン構築/署名/期限/EKU等を検証）
            primary.checkServerTrusted(chain, authType);
            return true;
        } catch (CertificateException e) {
            if (secondary != null) {
                secondary.checkServerTrusted(chain, authType);
                return true;
            }
            throw e;
        }
    }

    // ---- helpers ----

    /**
     * KeyStore から TrustManager を生成。
     * - ks == null → システム既定アンカー
     * - 実体が X509ExtendedTrustManager ならそのまま返す
     * - まれに X509TrustManager しか来ない実装向けに、簡易ラッパで Extended に見せる
     */
    private static X509ExtendedTrustManager tmFrom(KeyStore ks) {
        try {
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(
                    TrustManagerFactory.getDefaultAlgorithm());
            tmf.init(ks); // null でシステム既定

            for (var tm : tmf.getTrustManagers()) {
                if (tm instanceof X509ExtendedTrustManager) {
                    return (X509ExtendedTrustManager) tm;
                }
                if (tm instanceof X509TrustManager) {
                    // Extended メソッドは使わないので、2引数版へ委譲する薄いアダプタで包む
                    X509TrustManager base = (X509TrustManager) tm;
                    return new X509ExtendedTrustManager() {
                        @Override public void checkClientTrusted(X509Certificate[] c, String a) throws CertificateException { base.checkClientTrusted(c, a); }
                        @Override public void checkServerTrusted(X509Certificate[] c, String a) throws CertificateException { base.checkServerTrusted(c, a); }
                        @Override public X509Certificate[] getAcceptedIssuers() { return base.getAcceptedIssuers(); }
                        // 以下は Apache 側から呼ばれないが、念のため2引数へ委譲
                        @Override public void checkClientTrusted(X509Certificate[] c, String a, java.net.Socket s) throws CertificateException { base.checkClientTrusted(c, a); }
                        @Override public void checkServerTrusted(X509Certificate[] c, String a, java.net.Socket s) throws CertificateException { base.checkServerTrusted(c, a); }
                        @Override public void checkClientTrusted(X509Certificate[] c, String a, javax.net.ssl.SSLEngine e) throws CertificateException { base.checkClientTrusted(c, a); }
                        @Override public void checkServerTrusted(X509Certificate[] c, String a, javax.net.ssl.SSLEngine e) throws CertificateException { base.checkServerTrusted(c, a); }
                    };
                }
            }
            throw new IllegalStateException("No X509TrustManager available");
        } catch (Exception e) {
            throw new RuntimeException("Failed to create TrustManager", e);
        }
    }

    /** 追加 TrustStore ローダ（JKS/PKCS12 など） */
    public static KeyStore loadKeyStore(String type, Path path, char[] password) {
        try (InputStream in = Files.newInputStream(path)) {
            KeyStore ks = KeyStore.getInstance(type);
            ks.load(in, password);
            return ks;
        } catch (Exception e) {
            throw new RuntimeException("Failed to load KeyStore: " + path, e);
        }
    }
}
🔎 ポイント整理

「checkServerTrusted はインターフェース」 → その通り。実体（JDK実装）は X509ExtendedTrustManager で、checkServerTrusted(...) を実装しています。上のコードはその実体に委譲しています。

Extended を使うべき？ → Apache の TrustStrategy はソケット/SSLEngine文脈を渡さないため、2引数メソッドで十分です（Hostname 検証は別途 DefaultHostnameVerifier が担当）。

mTLS の切替 → 以前お渡しした TlsHttpClientFactory のままでOK（loadKeyMaterial(...) を設定すると双方向、外せば単方向）。Java 21 でも同じです。

失効確認 → 必要なら JVM プロパティで有効化（例：-Dcom.sun.net.ssl.checkRevocation=true -Dcom.sun.security.enableCRLDP=true -Dcom.sun.security.ocsp.enable=true）。

もし「JSSE が ハンドシェイク文脈（Socket/SSLEngine）込みで検証するのと完全に同じ挙動にしたい」なら、TrustStrategy を使わずに次の方法もあります：

システム＋追加CAを**一つの TrustStore（結合）**にして TrustManagerFactory を作る

その TrustManager[] を SSLContext.init(keyManagers, trustManagers, null) に直接渡す

その SSLContext を HttpClient に setSSLContext(...) で渡す

このルートだと JSSE の X509ExtendedTrustManager がハンドシェイクから直接呼ばれるため、より“素の挙動”に近くなります（必要ならこの結合 TrustStore 版も用意します）。




選択されていません選択されていません
ChatGPT の回答は必ずしも正しいとは限りません。重要な情報は確認するようにしてください。
