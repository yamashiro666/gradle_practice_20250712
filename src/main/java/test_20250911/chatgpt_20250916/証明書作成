コンテンツへとスキップする
チャット履歴

あなた:
keytoolでチェーン証明書を作る方法を教えて下さい。
　・ローカルの動作確認で使うので、自己署名でお願いします。
　・Wimdows、Macどちらでも動きますか。
　・サーバ証明書、クライアント証明書両方作ってください。
　・どちらもルート証明書、中間、末端の３つでお願いします。
　・keytoolの使い方、仕様も解説しつつ進めてください。
ChatGPT:

思考時間: 1m 44s
了解です。keytool だけで「3 階層（ルート／中間／末端）」のサーバ証明書とクライアント証明書を作る、完全ローカルな手順をまとめます。Windows／macOS どちらでも動きます（Java が入っていれば OK）。
以下では PKCS#12（.p12） をメインに使います（JKS も最後に変換方法を載せます）。パスワードは例として changeit を使います。

まず知っておきたい keytool のツボ
キーストア（keystore） … 秘密鍵＋その公開鍵証明書（と証明書チェーン）を格納。サーバ側やクライアント側の「自分の身分証」を持つ箱。

代表コマンド：

-genkeypair（鍵ペア＋自己署名証明書を作る）

-certreq（CSR を出す）

-importcert（署名済み証明書や CA 証明書を入れる）

-gencert（CSR を CA の秘密鍵で署名して証明書を発行する）

-exportcert（公開証明書だけ取り出す）

トラストストア（truststore） … 信頼する CA 証明書だけを格納（秘密鍵なし）。相手の証明書を検証するために使います。

拡張（-ext） … 証明書の性格付け。

例：

BasicConstraints:critical=ca:true,pathLen:1（CA 用）

KeyUsage:critical=keyCertSign,cRLSign（CA が他の証明書に署名できる）

ExtendedKeyUsage=serverAuth / clientAuth（用途をサーバ／クライアントに限定）

SubjectAlternativeName=DNS:localhost,IP:127.0.0.1（サーバ証明書で必須）

秘密鍵はどこ？ → .p12（キーストア）に入っています。ファイルとして素で出しません。（必要なら openssl で抽出可能）

作るもの（最終形）
ルート CA：root-ca.p12 / root-ca.crt

中間 CA：inter-ca.p12 / inter-ca.crt（署名者はルート）

サーバ：server.p12（秘密鍵＋チェーン） / server.crt（末端）
サーバ向けトラストストア：server-truststore.p12（相手＝クライアントを発行した CA を入れる）

クライアント：client.p12（秘密鍵＋チェーン） / client.crt（末端）
クライアント向けトラストストア：client-truststore.p12（相手＝サーバを発行した CA を入れる）

※今回は同一のルート／中間 CA でサーバ証明書とクライアント証明書の両方を発行します（チェーンは各末端に「ルート→中間→末端」で入ります）。

共通前提
Java 21 などの keytool が使えること（java -version / keytool -help で確認）。

作業用フォルダを用意：

macOS/Linux（bash/zsh）

mkdir tls-demo && cd tls-demo
PASS=changeit
Windows（PowerShell）

mkdir tls-demo | Out-Null; Set-Location tls-demo
$PASS = "changeit"
① ルート CA を作る（自己署名 CA）
macOS/Linux

keytool -genkeypair \
  -alias root-ca \
  -keyalg RSA -keysize 3072 -sigalg SHA256withRSA \
  -dname "CN=Dev Root CA, O=Example Org, C=JP" \
  -validity 3650 \
  -storetype PKCS12 -keystore root-ca.p12 -storepass "$PASS" -keypass "$PASS" \
  -ext BasicConstraints:critical=ca:true,pathLen:1 \
  -ext KeyUsage:critical=keyCertSign,cRLSign
keytool -exportcert -alias root-ca -keystore root-ca.p12 -storepass "$PASS" -rfc -file root-ca.crt
Windows（PowerShell）

keytool -genkeypair `
  -alias root-ca `
  -keyalg RSA -keysize 3072 -sigalg SHA256withRSA `
  -dname "CN=Dev Root CA, O=Example Org, C=JP" `
  -validity 3650 `
  -storetype PKCS12 -keystore root-ca.p12 -storepass $PASS -keypass $PASS `
  -ext "BasicConstraints:critical=ca:true,pathLen:1" `
  -ext "KeyUsage:critical=keyCertSign,cRLSign"
keytool -exportcert -alias root-ca -keystore root-ca.p12 -storepass $PASS -rfc -file root-ca.crt
② 中間 CA を作る（署名者はルート）
中間の鍵ペアを作って CSR を出す

ルートで署名して中間の CA 証明書にする

中間キーストアに「ルート証明書 → 署名済み中間証明書」をインポートしてチェーンを完成

macOS/Linux

# 中間鍵（と暫定自己署名）を作成
keytool -genkeypair \
  -alias inter-ca \
  -keyalg RSA -keysize 3072 -sigalg SHA256withRSA \
  -dname "CN=Dev Intermediate CA, O=Example Org, C=JP" \
  -validity 3650 \
  -storetype PKCS12 -keystore inter-ca.p12 -storepass "$PASS" -keypass "$PASS"

# CSR 作成
keytool -certreq -alias inter-ca -keystore inter-ca.p12 -storepass "$PASS" -file inter-ca.csr

# ルート CA が CSR を署名（中間は CA 用, pathLen=0）
keytool -gencert -alias root-ca -keystore root-ca.p12 -storepass "$PASS" \
  -infile inter-ca.csr -outfile inter-ca.crt -rfc \
  -ext BasicConstraints:critical=ca:true,pathLen:0 \
  -ext KeyUsage:critical=keyCertSign,cRLSign

# 中間キーストアにチェーンを構築
keytool -importcert -alias root-ca  -keystore inter-ca.p12 -storepass "$PASS" -file root-ca.crt    -noprompt
keytool -importcert -alias inter-ca -keystore inter-ca.p12 -storepass "$PASS" -file inter-ca.crt   -noprompt
Windows（PowerShell）

keytool -genkeypair `
  -alias inter-ca `
  -keyalg RSA -keysize 3072 -sigalg SHA256withRSA `
  -dname "CN=Dev Intermediate CA, O=Example Org, C=JP" `
  -validity 3650 `
  -storetype PKCS12 -keystore inter-ca.p12 -storepass $PASS -keypass $PASS

keytool -certreq -alias inter-ca -keystore inter-ca.p12 -storepass $PASS -file inter-ca.csr

keytool -gencert -alias root-ca -keystore root-ca.p12 -storepass $PASS `
  -infile inter-ca.csr -outfile inter-ca.crt -rfc `
  -ext "BasicConstraints:critical=ca:true,pathLen:0" `
  -ext "KeyUsage:critical=keyCertSign,cRLSign"

keytool -importcert -alias root-ca  -keystore inter-ca.p12 -storepass $PASS -file root-ca.crt  -noprompt
keytool -importcert -alias inter-ca -keystore inter-ca.p12 -storepass $PASS -file inter-ca.crt -noprompt
これで inter-ca.p12 には「秘密鍵＋（中間→ルート）のチェーン」が入ります。

③ サーバ証明書（末端）を作る（署名者は中間）
サーバ証明書では SAN（SubjectAlternativeName）が超重要。接続時のホスト名／IP が SAN に含まれていないと、クライアントは名前不一致で拒否します。

macOS/Linux（必要なら DNS/IP を調整）

# サーバ鍵（自己署名は後で置き換える）
keytool -genkeypair \
  -alias server \
  -keyalg RSA -keysize 3072 -sigalg SHA256withRSA \
  -dname "CN=localhost, O=Example Org, C=JP" \
  -validity 825 \
  -storetype PKCS12 -keystore server.p12 -storepass "$PASS" -keypass "$PASS"

# CSR
keytool -certreq -alias server -keystore server.p12 -storepass "$PASS" -file server.csr

# 中間 CA が署名（エンドエンティティ：ca:false + 用途を serverAuth、鍵用途は署名＋鍵カプセル化）
keytool -gencert -alias inter-ca -keystore inter-ca.p12 -storepass "$PASS" \
  -infile server.csr -outfile server.crt -rfc \
  -ext BasicConstraints:critical=ca:false \
  -ext KeyUsage:critical=digitalSignature,keyEncipherment \
  -ext ExtendedKeyUsage=serverAuth \
  -ext SubjectAlternativeName=DNS:localhost,IP:127.0.0.1,DNS:server.local

# サーバキーストアにチェーンを構築（順に：ルート→中間→末端）
keytool -importcert -alias root-ca  -keystore server.p12 -storepass "$PASS" -file root-ca.crt  -noprompt
keytool -importcert -alias inter-ca -keystore server.p12 -storepass "$PASS" -file inter-ca.crt -noprompt
keytool -importcert -alias server   -keystore server.p12 -storepass "$PASS" -file server.crt   -noprompt
Windows（PowerShell）

keytool -genkeypair `
  -alias server `
  -keyalg RSA -keysize 3072 -sigalg SHA256withRSA `
  -dname "CN=localhost, O=Example Org, C=JP" `
  -validity 825 `
  -storetype PKCS12 -keystore server.p12 -storepass $PASS -keypass $PASS

keytool -certreq -alias server -keystore server.p12 -storepass $PASS -file server.csr

keytool -gencert -alias inter-ca -keystore inter-ca.p12 -storepass $PASS `
  -infile server.csr -outfile server.crt -rfc `
  -ext "BasicConstraints:critical=ca:false" `
  -ext "KeyUsage:critical=digitalSignature,keyEncipherment" `
  -ext "ExtendedKeyUsage=serverAuth" `
  -ext "SubjectAlternativeName=DNS:localhost,IP:127.0.0.1,DNS:server.local"

keytool -importcert -alias root-ca  -keystore server.p12 -storepass $PASS -file root-ca.crt  -noprompt
keytool -importcert -alias inter-ca -keystore server.p12 -storepass $PASS -file inter-ca.crt -noprompt
keytool -importcert -alias server   -keystore server.p12 -storepass $PASS -file server.crt   -noprompt
④ クライアント証明書（末端）を作る（署名者は中間）
クライアント用は EKU=clientAuth。SAN は任意（識別に使うなら URI や EMAIL などを付ける）。

macOS/Linux

keytool -genkeypair \
  -alias client \
  -keyalg RSA -keysize 3072 -sigalg SHA256withRSA \
  -dname "CN=Dev Client, O=Example Org, C=JP" \
  -validity 825 \
  -storetype PKCS12 -keystore client.p12 -storepass "$PASS" -keypass "$PASS"

keytool -certreq -alias client -keystore client.p12 -storepass "$PASS" -file client.csr

keytool -gencert -alias inter-ca -keystore inter-ca.p12 -storepass "$PASS" \
  -infile client.csr -outfile client.crt -rfc \
  -ext BasicConstraints:critical=ca:false \
  -ext KeyUsage:critical=digitalSignature,keyEncipherment \
  -ext ExtendedKeyUsage=clientAuth \
  -ext SubjectAlternativeName=URI:urn:client:dev1,EMAIL:dev@example.com

keytool -importcert -alias root-ca  -keystore client.p12 -storepass "$PASS" -file root-ca.crt  -noprompt
keytool -importcert -alias inter-ca -keystore client.p12 -storepass "$PASS" -file inter-ca.crt -noprompt
keytool -importcert -alias client   -keystore client.p12 -storepass "$PASS" -file client.crt   -noprompt
Windows（PowerShell）

keytool -genkeypair `
  -alias client `
  -keyalg RSA -keysize 3072 -sigalg SHA256withRSA `
  -dname "CN=Dev Client, O=Example Org, C=JP" `
  -validity 825 `
  -storetype PKCS12 -keystore client.p12 -storepass $PASS -keypass $PASS

keytool -certreq -alias client -keystore client.p12 -storepass $PASS -file client.csr

keytool -gencert -alias inter-ca -keystore inter-ca.p12 -storepass $PASS `
  -infile client.csr -outfile client.crt -rfc `
  -ext "BasicConstraints:critical=ca:false" `
  -ext "KeyUsage:critical=digitalSignature,keyEncipherment" `
  -ext "ExtendedKeyUsage=clientAuth" `
  -ext "SubjectAlternativeName=URI:urn:client:dev1,EMAIL:dev@example.com"

keytool -importcert -alias root-ca  -keystore client.p12 -storepass $PASS -file root-ca.crt  -noprompt
keytool -importcert -alias inter-ca -keystore client.p12 -storepass $PASS -file inter-ca.crt -noprompt
keytool -importcert -alias client   -keystore client.p12 -storepass $PASS -file client.crt   -noprompt
⑤ トラストストア（相手の CA を信頼させる）
同じ CA で両方発行したので、両者ともルート＋中間を信頼すれば OK。

macOS/Linux

# サーバ側が信頼する CA（クライアント証明書の発行元）
keytool -importcert -alias root-ca  -file root-ca.crt  -storetype PKCS12 -keystore server-truststore.p12  -storepass "$PASS" -noprompt
keytool -importcert -alias inter-ca -file inter-ca.crt -storetype PKCS12 -keystore server-truststore.p12  -storepass "$PASS" -noprompt

# クライアント側が信頼する CA（サーバ証明書の発行元）
keytool -importcert -alias root-ca  -file root-ca.crt  -storetype PKCS12 -keystore client-truststore.p12  -storepass "$PASS" -noprompt
keytool -importcert -alias inter-ca -file inter-ca.crt -storetype PKCS12 -keystore client-truststore.p12  -storepass "$PASS" -noprompt
Windows（PowerShell）

keytool -importcert -alias root-ca  -file root-ca.crt  -storetype PKCS12 -keystore server-truststore.p12  -storepass $PASS -noprompt
keytool -importcert -alias inter-ca -file inter-ca.crt -storetype PKCS12 -keystore server-truststore.p12  -storepass $PASS -noprompt

keytool -importcert -alias root-ca  -file root-ca.crt  -storetype PKCS12 -keystore client-truststore.p12  -storepass $PASS -noprompt
keytool -importcert -alias inter-ca -file inter-ca.crt -storetype PKCS12 -keystore client-truststore.p12  -storepass $PASS -noprompt
⑥ できあがり確認（チェーン長や用途）
# macOS/Linux
keytool -list -v -keystore server.p12 -storepass "$PASS" | sed -n '1,80p'
keytool -list -v -keystore client.p12 -storepass "$PASS" | sed -n '1,80p'
keytool -list -v -keystore inter-ca.p12 -storepass "$PASS" | sed -n '1,80p'
PowerShell なら：

keytool -list -v -keystore server.p12 -storepass $PASS | more
「証明書チェーンの長さ」 が 3（ルート→中間→末端）になっていれば成功。

サーバ証明書に SAN が入り、EKU が serverAuth になっているか、クライアント証明書が clientAuth になっているかを確認。

⑦ JKS が必要なら変換
# macOS/Linux
keytool -importkeystore -srckeystore server.p12  -srcstoretype PKCS12 -srcstorepass "$PASS" \
                          -destkeystore server.jks -deststoretype JKS    -deststorepass "$PASS"
keytool -importkeystore -srckeystore client.p12  -srcstoretype PKCS12 -srcstorepass "$PASS" \
                          -destkeystore client.jks -deststoretype JKS    -deststorepass "$PASS"
keytool -importkeystore -srckeystore server-truststore.p12 -srcstoretype PKCS12 -srcstorepass "$PASS" \
                          -destkeystore server-truststore.jks -deststoretype JKS -deststorepass "$PASS"
keytool -importkeystore -srckeystore client-truststore.p12 -srcstoretype PKCS12 -srcstorepass "$PASS" \
                          -destkeystore client-truststore.jks -deststoretype JKS -deststorepass "$PASS"
（PowerShell でも同じ構文で動きます）

⑧ （参考）秘密鍵を取り出したい場合
通常は不要ですが、検証用途で PEM を取りたいなら openssl を使用（.p12 → PEM）。

取り扱いは厳重に！

macOS/Linux

# 末端サーバの秘密鍵（暗号化なし）
openssl pkcs12 -in server.p12 -nocerts -nodes -out server.key.pem -passin pass:$PASS
# 末端サーバの証明書（チェーン全部）
openssl pkcs12 -in server.p12 -clcerts -nokeys -out server.chain.pem -passin pass:$PASS
Windows（PowerShell）

openssl pkcs12 -in server.p12 -nocerts -nodes -out server.key.pem -passin pass:$PASS
openssl pkcs12 -in server.p12 -clcerts -nokeys -out server.chain.pem -passin pass:$PASS
⑨ 実運用に向けた注意（ローカル検証でも抑えたいポイント）
サーバ名の検証は SAN が命：クライアント接続のホスト名／IP を SAN に必ず入れる。

用途を厳密化：サーバは ExtendedKeyUsage=serverAuth、クライアントは clientAuth を付与。

CA の権限は CA にだけ：CA 証明書に BasicConstraints: ca:true と KeyUsage: keyCertSign,cRLSign、末端には 付けない。

有効期限：ローカルでも 2～3 年程度に留めるのが無難（ここでは例として 825 日 ≒ 27 カ月）。

Java の既定：近年は PKCS#12 が既定。古いツール連携が必要な場合だけ JKS を使う。

必要なら、上で作ったファイルを使った Java（HttpsServer / SSLSocket / Spring Boot）側の KeyStore / TrustStore の設定例（単方向・双方向切り替え）もすぐに書きます。SAN の値（localhost 以外の FQDN／IP）を決めていれば教えてください。

あなた:
keytool -genkeypair \
  -alias root-ca \
  -keyalg RSA -keysize 3072 -sigalg SHA256withRSA \
  -dname "CN=Dev Root CA, O=Example Org, C=JP" \
  -validity 3650 \
  -storetype PKCS12 -keystore root-ca.p12 -storepass "$PASS" -keypass "$PASS" \
  -ext BasicConstraints:critical=ca:true,pathLen:1 \
  -ext KeyUsage:critical=keyCertSign,cRLSign
keytool -exportcert -alias root-ca -keystore root-ca.p12 -storepass "$PASS" -rfc -file root-ca.crt

このコマンドでできるroot-ca.crtは自分で署名した証明書ということになるのでしょうか?
ChatGPT:

思考時間: 14s
はい、そのとおりです。
その2コマンドの流れ（-genkeypair → -exportcert）で得られる root-ca.crt は自己署名証明書（self-signed certificate） になります。

なぜ自己署名と言えるか
keytool -genkeypair は 鍵ペアと同時に“その鍵で自分自身を署名した証明書” を作ります（最初は必ず自己署名）。

その直後に -exportcert で取り出した root-ca.crt の Issuer（発行者）と Subject（主体） が同一 です。

署名検証も 同じ鍵ペアの公開鍵で検証できる（自分で自分に署名）ため、自己署名です。

付けている拡張 BasicConstraints: ca:true は「この証明書は CA 用」を意味します（“自己署名かどうか”の判定ではなく、CA 権限の宣言）。

確認コマンド
どちらでも OK です。

keytool:

keytool -printcert -file root-ca.crt
出力で Owner（= Subject） と Issuer が同じ DN（例: CN=Dev Root CA, O=Example Org, C=JP）になっていれば自己署名。

OpenSSL（入っていれば）:

openssl x509 -in root-ca.crt -noout -text
Subject: と Issuer: が一致しているはずです。

補足
自己署名＝すぐに信頼される ではありません。ローカル検証では、この root-ca.crt をクライアント／サーバの トラストストア に取り込んで「このルートを信頼する」と明示する必要があります。

中間や末端（サーバ／クライアント）証明書を“自己署名ではなく”発行したい場合は、対象の CSR を作って keytool -gencert を CA（今回の root-ca または inter-ca）の秘密鍵で実行し、その結果を対象キーストアに -importcert で入れる、という流れになります。




選択されていません選択されていません
ChatGPT の回答は必ずしも正しいとは限りません。重要な情報は確認するようにしてください。
